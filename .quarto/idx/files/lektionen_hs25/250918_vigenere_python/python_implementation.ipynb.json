{"title":"10 Vigenère Cipher Implementation in Python","markdown":{"yaml":{"title":"10 Vigenère Cipher Implementation in Python"},"containsRefs":false,"markdown":"\n\n\n\n\n\n\nThis notebook presents a possible implementation of the Vigenère cipher in Python.\n\nThe `vigenere()` function is explained in detail below.\n\nThe function signature\n\n```python\ndef vigenere(text: str, key: str, mode: str) -> str:\n```\n\nshows that the function expects three parameters:\n* `text`: The string to be encrypted or decrypted.\n* `key`: The key for encryption or decryption as a string.\n* `mode`: The mode that specifies whether the text should be encrypted or\n  decrypted. Possible values are `'encrypt'` for\n  encryption and `'decrypt'` for decryption (although this is\n  not directly apparent from the signature).\n\nFollowing the signature is a detailed docstring that describes the function and its parameters. Although written in English, it is self-explanatory.\n\nThe docstring is followed by a check to see if valid values were passed for the\n`mode` parameter. If not, a \n`ValueError` exception is raised.\n\n```python\nif mode not in ['encrypt', 'decrypt']:\n    raise ValueError(\"Mode must be 'encrypt' or 'decrypt'\")\n```\n\nTo perform this check, the allowed values are provided in a\nlist. It then checks if the value assigned to `mode`\nis contained in the list. If this is not the case,\nan error message is displayed and the function's execution\nis terminated.\n\nIf the `mode` parameter contains a valid value, the\nactual function logic comes into play.\n\nFirst, the length of the key is assigned to the variable `key_length` in\n\n```python\nkey_length = len(key)\n```\n\nThis information will be needed later\nto iterate over the key's text in a special type of loop.\n\nAfter this assignment, the function splits into the encryption and\ndecryption branches.\n\nFirst, the encryption - initiated with `if mode == 'encrypt':` -\nis considered.\n\nInside this block, an empty string `cipher` is first\ninitialized, which will later hold the encrypted characters. \n\nThen, a `for` loop is used to iterate over the text to be encrypted.\n\n```python\nfor i, char in enumerate(text):\n```\n\nIn this loop, the `enumerate()` function is used. This\nfunction returns a tuple consisting of the index and the respective element of the\nstructure being iterated over. The values of the tuple are assigned to the \nvariables `i` and `char`.\n\nThe variables `i` and `char` are used inside the loop to\nconvert the individual characters of the text into a number.\n\n```python\n    char_num = ord(char) - ord('A')\n    key_num = ord(key[i % key_length]) - ord('A')\n```\n\nThe `ord()` function converts a letter into the corresponding number\nfrom the ASCII table. To ensure the numbers are in the range of 0 to 25,\nthe ASCII value of the letter 'A' is subtracted. The letter 'A'\nis used because the characters to be encrypted are specified in uppercase.  \nSince the key can be shorter than the text to be encrypted,\n`i % key_length` is used to iterate over the key. The modulo operator\n`%` ensures that the index value of the used index always stays between\n0 and the length of the key `key_length`. This ensures\nthat the key is started again from the beginning\nonce the end of the key is reached. The individual letters of the key are then\nprocessed in the same way as the\nletters of the text.\n\nAfter the letters of the text and the key have been converted into numbers,\nthe actual encryption is performed according to the\nformula $C_i = (P_i + K_i)\\ mod\\ 26$.\n\n```python\n    cipher_num = (char_num + key_num) % 26\n```\n\nThe numerical values of the encrypted text are then converted back\ninto letters and appended to the string `cipher`. For this,\nthe `chr()` function is used, which converts a number into the corresponding\nletter of the ASCII table. Since the numerical values are in the range\nof 0 to 25, the ASCII value of the letter 'A' is added. \n\n```python\n    cipher += chr(cipher_num + ord('A'))\n```\n\nThe string stored under `cipher` is returned at the end of the block.\n\nIn the second block, the decryption - initiated with `else:` -\nis performed. The process is very similar to that of encryption,\nhowever, the inverse formula ($P_i = (C_i - K_i + 26)\\ mod\\ 26$) is used here.\n\n```python\n    plain_num = (char_num - key_num + 26) % 26\n    plain += chr(plain_num + ord('A'))\n```\n\nEverything else corresponds to the procedure for encryption.\n","srcMarkdownNoYaml":"\n\n\n\n\n\n\nThis notebook presents a possible implementation of the Vigenère cipher in Python.\n\nThe `vigenere()` function is explained in detail below.\n\nThe function signature\n\n```python\ndef vigenere(text: str, key: str, mode: str) -> str:\n```\n\nshows that the function expects three parameters:\n* `text`: The string to be encrypted or decrypted.\n* `key`: The key for encryption or decryption as a string.\n* `mode`: The mode that specifies whether the text should be encrypted or\n  decrypted. Possible values are `'encrypt'` for\n  encryption and `'decrypt'` for decryption (although this is\n  not directly apparent from the signature).\n\nFollowing the signature is a detailed docstring that describes the function and its parameters. Although written in English, it is self-explanatory.\n\nThe docstring is followed by a check to see if valid values were passed for the\n`mode` parameter. If not, a \n`ValueError` exception is raised.\n\n```python\nif mode not in ['encrypt', 'decrypt']:\n    raise ValueError(\"Mode must be 'encrypt' or 'decrypt'\")\n```\n\nTo perform this check, the allowed values are provided in a\nlist. It then checks if the value assigned to `mode`\nis contained in the list. If this is not the case,\nan error message is displayed and the function's execution\nis terminated.\n\nIf the `mode` parameter contains a valid value, the\nactual function logic comes into play.\n\nFirst, the length of the key is assigned to the variable `key_length` in\n\n```python\nkey_length = len(key)\n```\n\nThis information will be needed later\nto iterate over the key's text in a special type of loop.\n\nAfter this assignment, the function splits into the encryption and\ndecryption branches.\n\nFirst, the encryption - initiated with `if mode == 'encrypt':` -\nis considered.\n\nInside this block, an empty string `cipher` is first\ninitialized, which will later hold the encrypted characters. \n\nThen, a `for` loop is used to iterate over the text to be encrypted.\n\n```python\nfor i, char in enumerate(text):\n```\n\nIn this loop, the `enumerate()` function is used. This\nfunction returns a tuple consisting of the index and the respective element of the\nstructure being iterated over. The values of the tuple are assigned to the \nvariables `i` and `char`.\n\nThe variables `i` and `char` are used inside the loop to\nconvert the individual characters of the text into a number.\n\n```python\n    char_num = ord(char) - ord('A')\n    key_num = ord(key[i % key_length]) - ord('A')\n```\n\nThe `ord()` function converts a letter into the corresponding number\nfrom the ASCII table. To ensure the numbers are in the range of 0 to 25,\nthe ASCII value of the letter 'A' is subtracted. The letter 'A'\nis used because the characters to be encrypted are specified in uppercase.  \nSince the key can be shorter than the text to be encrypted,\n`i % key_length` is used to iterate over the key. The modulo operator\n`%` ensures that the index value of the used index always stays between\n0 and the length of the key `key_length`. This ensures\nthat the key is started again from the beginning\nonce the end of the key is reached. The individual letters of the key are then\nprocessed in the same way as the\nletters of the text.\n\nAfter the letters of the text and the key have been converted into numbers,\nthe actual encryption is performed according to the\nformula $C_i = (P_i + K_i)\\ mod\\ 26$.\n\n```python\n    cipher_num = (char_num + key_num) % 26\n```\n\nThe numerical values of the encrypted text are then converted back\ninto letters and appended to the string `cipher`. For this,\nthe `chr()` function is used, which converts a number into the corresponding\nletter of the ASCII table. Since the numerical values are in the range\nof 0 to 25, the ASCII value of the letter 'A' is added. \n\n```python\n    cipher += chr(cipher_num + ord('A'))\n```\n\nThe string stored under `cipher` is returned at the end of the block.\n\nIn the second block, the decryption - initiated with `else:` -\nis performed. The process is very similar to that of encryption,\nhowever, the inverse formula ($P_i = (C_i - K_i + 26)\\ mod\\ 26$) is used here.\n\n```python\n    plain_num = (char_num - key_num + 26) % 26\n    plain += chr(plain_num + ord('A'))\n```\n\nEverything else corresponds to the procedure for encryption.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"python_implementation.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","theme":["cosmo","brand"],"author":"Jacques Mock Schindler","date":"2025-09-23","date-format":"DD.MM.YYYY","title":"10 Vigenère Cipher Implementation in Python"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"lualatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","pdf-engine-opts":["-shell-escape"],"toc":false,"include-in-header":["../../../preamble.tex"],"output-file":"python_implementation.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"mainfont":"Arial","fontsize":"11pt","documentclass":"scrartcl","classoption":"a4paper","listings-package":{"columns":"fullflexible","break-at-whitespace":true},"author":"Jacques Mock Schindler","date":"2025-09-23","date-format":"DD.MM.YYYY","title":"10 Vigenère Cipher Implementation in Python"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}