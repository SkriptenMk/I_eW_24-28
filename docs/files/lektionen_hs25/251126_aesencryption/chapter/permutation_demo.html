<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Deterministische Permutation – Mini-Key-Schedule</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; }
    h1 { font-size: 1.4rem; margin-bottom: 0.5rem; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin: 16px 0; }
    label { display:block; margin: 8px 0 4px; }
    input, button { padding: 8px 12px; border: 1px solid #ccc; border-radius: 8px; }
    button { cursor: pointer; }
    table { border-collapse: collapse; width: 100%; margin: 12px 0; }
    th, td { border: 1px solid #e5e5e5; padding: 6px 8px; text-align: center; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .muted { color: #555; font-size: 0.95rem; }
    .pill { display:inline-block; padding:2px 8px; border-radius: 999px; border:1px solid #ddd; margin:2px; }
    .rowtitle { text-align: left; white-space: nowrap; }
    .note { font-size: 0.9rem; color: #444; }
    .ok { border-color: #3c9; }
  </style>
</head>
<body>
  <h1>Deterministische Permutation – Mini-Key-Schedule (Demo)</h1>
  <p class="muted">Dieses Beispiel, zeigt, wie aus <b>einem</b> Schlüssel pro Runde automatisch ein Permutationsmuster entsteht.
    <br><br>Regel (nur Beispiel, nicht sicher!):<br><br>r = Runde<br>k=Schlüssel<br>n=Blocklänge<br><br>Für Runde <code>r</code> bei Blocklänge <code>n</code> und Schlüssel <code>k</code> gilt
    <code>s = ((r * k) mod n) + 1</code>.<br><br>Permutationsmuster ist eine zyklische Rotation, beginnend bei <code>s</code>.</p>

  <div class="card">
    <div class="grid">
      <div>
        <label for="bits">Klartext-Bits (nur 0/1, Länge n):</label>
        <input id="bits" class="mono" value="10110010" size="40" />
      </div>
      <div>
        <label for="key">Schlüssel k (Ganzzahl ≥1):</label>
        <input id="key" type="number" min="1" value="3" />
      </div>
      <div>
        <label for="rounds">Runden r (1–20):</label>
        <input id="rounds" type="number" min="1" max="20" value="3" />
      </div>
    </div>
    <div style="margin-top:12px;">
      <button id="run">Permutation anwenden</button>
      <button id="decrypt">Entschlüsseln (inverse Permutationen)</button>
      <button id="reset">Zurücksetzen</button>
    </div>
  </div>

  <div id="output"></div>

  <div class="card">
    <b>Hinweis:</b>
    <p class="note">
      In echten Verfahren wie <b>AES</b> werden die Rundenschlüssel aus dem Startschlüssel über eine
      <i>Key-Schedule</i> gewonnen (S‑Box, RotWord, Rcon, XOR). Diese Demo zeigt nur das <b>Prinzip</b>
      der deterministischen Ableitung und der wiederholten Anwendung pro Runde.
    </p>
  </div>

<script>
function isBits(s){ return /^[01]+$/.test(s); }

function rotatePattern(n, startIdx1Based){
  // Builds a pattern [start, start+1, ..., n, 1, ..., start-1]
  const start = ((startIdx1Based-1) % n) + 1;
  const arr = [];
  for(let i=start; i<=n; i++) arr.push(i);
  for(let i=1; i<start; i++) arr.push(i);
  return arr;
}

function applyPermutation(bitsArray, pattern){
  // pattern i says: new position i takes old position pattern[i-1]
  const out = new Array(bitsArray.length);
  for(let i=0;i<bitsArray.length;i++){
    const sourcePos = pattern[i]-1;
    out[i] = bitsArray[sourcePos];
  }
  return out;
}

function inversePattern(pattern){
  // Given pattern P (1-based), produce inv so that apply(inv) undoes apply(P)
  const n = pattern.length;
  const inv = new Array(n);
  for(let i=0;i<n;i++){
    const oldPos = pattern[i]; // old goes to new i+1
    inv[oldPos-1] = i+1;
  }
  return inv;
}

function renderRoundTable(roundIndex, before, pattern, after){
  const n = before.length;
  const posRow = Array.from({length:n}, (_,i)=>i+1);
  const html = `
    <div class="card">
      <div><span class="pill">Runde ${roundIndex}</span>
      <span class="muted">Start s = ((r * k) mod n) + 1 = ((${roundIndex} * ${Number(keyEl.value)}) mod ${before.length}) + 1</span></div>
      <table>
        <tr><th class="rowtitle">Position</th>${posRow.map(p=>`<th>${p}</th>`).join("")}</tr>
        <tr><td class="rowtitle">Vorher</td>${before.map(b=>`<td class="mono">${b}</td>`).join("")}</tr>
        <tr><td class="rowtitle">Muster P</td>${pattern.map(p=>`<td>${p}</td>`).join("")}</tr>
        <tr><td class="rowtitle">Nachher</td>${after.map(b=>`<td class="mono">${b}</td>`).join("")}</tr>
      </table>
    </div>
  `;
  return html;
}

const bitsEl = document.getElementById('bits');
const keyEl = document.getElementById('key');
const roundsEl = document.getElementById('rounds');
const outEl = document.getElementById('output');
const runBtn = document.getElementById('run');
const decBtn = document.getElementById('decrypt');
const resetBtn = document.getElementById('reset');

function run(direction){ // direction: "enc" or "dec"
  const bitsStr = bitsEl.value.trim();
  const k = Number(keyEl.value);
  const r = Number(roundsEl.value);
  if(!isBits(bitsStr)){ alert("Bitte nur 0/1 in den Bits eingeben."); return; }
  if(k<1 || !Number.isInteger(k)){ alert("Schlüssel k muss eine ganze Zahl ≥1 sein."); return; }
  if(r<1 || r>20 || !Number.isInteger(r)){ alert("Runden müssen 1–20 sein."); return; }

  const n = bitsStr.length;
  let current = bitsStr.split("");
  let html = "";
  if(direction === "enc"){
    for(let round=1; round<=r; round++){
      const s = ((round * k) % n) + 1;
      const pattern = rotatePattern(n, s);
      const after = applyPermutation(current, pattern);
      html += renderRoundTable(round, current, pattern, after);
      current = after;
    }
    html += `<div class="card ok"><b>Geheimtext:</b> <span class="mono">${current.join("")}</span></div>`;
  }else{
    // Build all forward patterns, then apply inverses in reverse order
    const patterns = [];
    for(let round=1; round<=r; round++){
      const s = ((round * k) % n) + 1;
      patterns.push(rotatePattern(n, s));
    }
    for(let idx=r; idx>=1; idx--){
      const pat = patterns[idx-1];
      const inv = inversePattern(pat);
      const before = current;
      const after = applyPermutation(before, inv);
      html += `
        <div class="card">
          <div><span class="pill">Entschlüsseln – Inverse Runde ${idx}</span></div>
          <table>
            <tr><th class="rowtitle">Position</th>${Array.from({length:n},(_,i)=>`<th>${i+1}</th>`).join("")}</tr>
            <tr><td class="rowtitle">Vorher</td>${before.map(b=>`<td class="mono">${b}</td>`).join("")}</tr>
            <tr><td class="rowtitle">Inverse P</td>${inv.map(p=>`<td>${p}</td>`).join("")}</tr>
            <tr><td class="rowtitle">Nachher</td>${after.map(b=>`<td class="mono">${b}</td>`).join("")}</tr>
          </table>
        </div>
      `;
      current = after;
    }
    html += `<div class="card ok"><b>Klartext (nach Entschlüsselung):</b> <span class="mono">${current.join("")}</span></div>`;
  }
  outEl.innerHTML = html;
}

runBtn.addEventListener('click', ()=> run("enc"));
decBtn.addEventListener('click', ()=> run("dec"));
resetBtn.addEventListener('click', ()=> { outEl.innerHTML = ""; });
</script>
</body>
</html>
