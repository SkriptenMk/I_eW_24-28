[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "This site contains all the information you need for your computer science course."
  },
  {
    "objectID": "index.html#schedule",
    "href": "index.html#schedule",
    "title": "Welcome",
    "section": "Schedule",
    "text": "Schedule\nThe schedule reflects the current state of planning. Changes are to be expected during the course of the semester.\n\n\n\nDate\nTopic\n\n\n\n\n20.08.2025\nNetworks: TCP/IP\n\n\n27.08.2025\nNetworks: Wireshark\n\n\n03.09.2025\nNetworks: Exercise\n\n\n10.09.2025\nCryptology: Caesar\n\n\n24.09.2025\nCryptology: Vigenère Chiffre\n\n\n22.10.2025\nTest\n\n\n29.10.2025\nCryptology: Break Vigenère\n\n\n05.11.2025\nCryptology: Public Key Cryptography (Graph based)\n\n\n12.11.2025\nCryptology: RSA\n\n\n19.11.2025\nCryptology: digital Signatures\n\n\n26.11.2025\nAI: Kind of a Definition\n\n\n03.12.2025\nAI\n\n\n10.12.2025\nAI\n\n\n17.12.2025\nTest\n\n\n07.01.2026\nAI\n\n\n14.01.2026\nAI\n\n\n21.01.2026\nAI"
  },
  {
    "objectID": "index.html#grading",
    "href": "index.html#grading",
    "title": "Welcome",
    "section": "Grading",
    "text": "Grading\nTwo written examinations are scheduled per semester. In addition, oral participation is graded. Oral participation includes, in particular, asking questions.\nThe Final grades are calculated as a weighted average of the two. written examinations and the oral participation grade. The Average grade of the two written examinations is weighted at 90%, while the grade for oral participation is weighted at 10%.\nYou have the opportunity to improve your mark in an upcoming exam. If you report an issue through the link on the right-hand side before the exam takes place, you may be awarded a maximum increase of one mark.\nTo report an issue, you must sign up with  GitHub. Use your school email address to register."
  },
  {
    "objectID": "index.html#appointments",
    "href": "index.html#appointments",
    "title": "Welcome",
    "section": "Appointments",
    "text": "Appointments\nIf you would like a personal appointment, here is the link to  Rent-A-Mock."
  },
  {
    "objectID": "files/materialien/240904/schweizerfahne_muloe.html",
    "href": "files/materialien/240904/schweizerfahne_muloe.html",
    "title": "Einfache Zeichnungen",
    "section": "",
    "text": "Als Beispiel für die Vorgehnsweise wird hier die Französische Trikolore gezeichnet. Das Seitenverhältnis der Trikolore ist 2 zu 3.\n# Import der erforderlichen Libraries (nur einmal pro Notebook nötig)\nfrom pytamaro.de import (\n    rot, blau, weiss,\n    rechteck, kreis_sektor,\n    drehe, neben, ueber,\n    zeige_grafik\n)\nAls erstes werden die einzelnen Rechtecke gezeichnet.\nbleu = rechteck(10, 20, blau)\nzeige_grafik(bleu)\nblanc = rechteck(10, 20, weiss)\nzeige_grafik(blanc)\nrouge = rechteck(10, 20, rot)\nzeige_grafik(rouge)\nAnschliessend werden die Einzelteile zusammengesetzt.\nzweidrittel = neben(bleu, blanc)\nzeige_grafik(zweidrittel)\ntrikolore = neben(zweidrittel, rouge)\nzeige_grafik(trikolore)"
  },
  {
    "objectID": "files/materialien/240904/schweizerfahne_muloe.html#tessiner-wappen",
    "href": "files/materialien/240904/schweizerfahne_muloe.html#tessiner-wappen",
    "title": "Einfache Zeichnungen",
    "section": "Tessiner Wappen",
    "text": "Tessiner Wappen\nPyTamaro wird von einem Team an der Università della Svizzera italiana in Lugano entwickelt. Zu ehren des Standortkantons geht es in einer ersten Übung darum, das Tessiner Wappen zu zeichnen.\n\n\nVorgehen\n\nDas Wappen wird in Einzelteile zerlegt.\n\nDie Einzelteile werden aufgelistet.\n\nrotes Rechteck\nblaues Rechteck\nroter Viertelkreis\nblauer Viertelkreis\n\nDie Einzelteile werden mit PyTamaro programmiert.\nDie Einzelteile werden mit PyTamaro zusammengesetzt.\n\n\n\nUmsetzung in PyTamaro\n\nrotes_rechteck = rechteck(10, 15, rot)\nzeige_grafik(rotes_rechteck)\n\n\n\n\n\n\n\n\n\nblaues_rechteck = rechteck(10, 15, blau)\nzeige_grafik(blaues_rechteck)\n\n\n\n\n\n\n\n\n\nroter_viertelkreis = kreis_sektor(10, 90, rot)\nroter_viertelkreis = drehe(180, roter_viertelkreis)\nzeige_grafik(roter_viertelkreis)\n\n\n\n\n\n\n\n\n\nblauer_viertelkreis = kreis_sektor(10, 90, blau)\nblauer_viertelkreis = drehe(270, blauer_viertelkreis)\nzeige_grafik(blauer_viertelkreis)\n\n\n\n\n\n\n\n\n\nobere_haelfte = neben(rotes_rechteck, blaues_rechteck)\nzeige_grafik(obere_haelfte)\n\n\n\n\n\n\n\n\n\nuntere_haelfte = neben(roter_viertelkreis, blauer_viertelkreis)\nzeige_grafik(untere_haelfte)\n\n\n\n\n\n\n\n\n\nti = ueber(obere_haelfte, untere_haelfte)\nzeige_grafik(ti)\n\n\n\n\n\n\n\n\n\n\nCode Aufräumen (Refactoring)\nDie Erste Aufgabe beim Programmieren ist sicher die Lösung des konkreten Problems. Eng damit Verbunden ist allerdings auch die übersichtliche Darstellung des Programms. Dabei ist insbesondere darauf zu achten, das Wiederholungen so weit wie möglich vermieden werden. Unten steht der bereinigte Code der verwendet wurde, um das Tessiner Wappen zu zeichnen.\nrotes_rechteck = rechteck(10, 15, rot)\nblaues_rechteck = rechteck(10, 15, blau)\nroter_viertelkreis = kreis_sektor(10, 90, rot)\nroter_viertelkreis = drehe(180, roter_viertelkreis)\nblauer_viertelkreis = kreis_sektor(10, 90, blau)\nblauer_viertelkreis = drehe(270, blauer_viertelkreis)\nobere_haelfte = neben(rotes_rechteck, blaues_rechteck)\nuntere_haelfte = neben(roter_viertelkreis, blauer_viertelkreis)\nti = ueber(obere_haelfte, untere_haelfte)\nzeige_grafik(ti)\nDieser Code soll nun so bereinigt werden, dass Wiederholungen vermieden werden. Dabei soll allerdings dessen Verständlichkeit nicht leiden.\n\nbreite = 50\nlaenge = 1.5 * breite\nrotes_rechteck = rechteck(breite, laenge, rot)\nblaues_rechteck = rechteck(breite, laenge, blau)\nroter_viertelkreis = kreis_sektor(breite, 90, rot)\nroter_viertelkreis = drehe(180, roter_viertelkreis)\nblauer_viertelkreis = kreis_sektor(breite, 90, blau)\nblauer_viertelkreis = drehe(270, blauer_viertelkreis)\nobere_haelfte = neben(rotes_rechteck, blaues_rechteck)\nuntere_haelfte = neben(roter_viertelkreis, blauer_viertelkreis)\nti = ueber(obere_haelfte, untere_haelfte)\nzeige_grafik(ti)"
  },
  {
    "objectID": "files/materialien/240904/schweizerfahne_muloe.html#schweizerfahne",
    "href": "files/materialien/240904/schweizerfahne_muloe.html#schweizerfahne",
    "title": "Einfache Zeichnungen",
    "section": "Schweizerfahne",
    "text": "Schweizerfahne\nAlle kennen die Schweizerfahne. Ein weisses Kreuz auf rotem Grund. Was viele nicht wissen, dass es für die genauen Proportionen eine gesetzliche Grundlage gibt, das Bundesgesetz über den Schutz des Schweizerwappens und anderer öffentlicher Zeichen (Wappenschutzgesetz, WSchG). Das WSchG regelt in seinem Anhang 2 die Proportionen und die Farben der Schweizerfahne.\n\nBasierend auf diesen Vorgaben soll die Schweizerfahne gezeichnet werden.\n\nUmsetzung in PyTamaro\n\nfrom pytamaro.de import (\n    ueberlagere,\n    weiss, rgb_farbe\n)\n\n\nhintergrundfarbe = rgb_farbe(255, 0, 0)\neinheit = 5\nbreite = 20 * einheit\nhoehe = 6 * einheit\nkante = 32 * einheit\n\ntuch = rechteck(kante, kante, hintergrundfarbe)\nbalken = rechteck(breite, hoehe, weiss)\nbalken_senkrecht = drehe(90, balken)\nkreuz = ueberlagere(balken, balken_senkrecht)\nfahne = ueberlagere(kreuz, tuch)\nzeige_grafik(fahne)"
  },
  {
    "objectID": "files/lektionen_hs25/250917_vigenre/vigenere.html",
    "href": "files/lektionen_hs25/250917_vigenre/vigenere.html",
    "title": "9 Polyalphabetic Ciphers",
    "section": "",
    "text": "As early as the 9th century, the great weakness of monoalphabetic ciphers (Caesar cipher) was recognized in the Islamic world. The distribution of letters follows a specific but constant pattern in every language. As explained in the last section, the letter ‘e’ is by far the most common letter in the English language.\nTo demonstrate that this applies to any given (longer) texts, the text of the  Book of Revelations from the King James Bible  was analyzed. The resulting distribution of letters was plotted against the distribution from the table. The result is shown in the figure below.\n\n\nCode\nimport string\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef file_reader(path : str) -&gt; str:\n\n    with open(path, mode='r', encoding='utf-8') as f:\n        text = f.read()\n\n    return text\n\ndef text_cleaning(text : str) -&gt; str:\n    clean = text.upper() \\\n                .replace('Ä', 'AE') \\\n                .replace('Ö', 'OE') \\\n                .replace('Ü', 'UE') \\\n                .replace('ß', 'SS') \\\n                .replace(' ', '') \\\n\n    cleaned_text = ''\n\n    for c in clean:\n        if c.isalpha():\n            cleaned_text += c\n    \n    return cleaned_text\n\ndef file_writer(path : str, text : str) -&gt; None:\n    i = 0\n    grouped_text = \"\"\n    for c in text:\n        i += 1\n        if i % 50 == 0:\n            grouped_text += c + \"\\n\"\n        elif i % 5 == 0:\n            grouped_text += c + \" \"\n        else:\n            grouped_text += c\n        \n    with open(path, mode='w', encoding='utf-8') as f:\n        f.write(grouped_text)\n        \nrevelation = file_reader('revelation.txt')\ncleaned_revelation = text_cleaning(revelation)\nfile_writer('cleaned_revelation.txt', cleaned_revelation)\n\ndef letter_frequency(text: str) -&gt; dict:\n    frequency = {}\n    total_letters = 0\n    \n    for char in text:\n        if char not in frequency:\n            frequency[char] = 1\n        else:\n            frequency[char] += 1\n        total_letters += 1\n        \n    for key, value in frequency.items():\n        frequency[key] = (value / total_letters) * 100\n        \n           \n    return frequency\n\nfrequency_revelation = letter_frequency(cleaned_revelation)\n\n\nstandard_frequency = {\n    'E': 12.02,\n    'T': 9.10,\n    'A': 8.12,\n    'O': 7.68,\n    'I': 7.31,\n    'N': 6.95,\n    'S': 6.28,\n    'R': 6.02,\n    'H': 5.92,\n    'D': 4.32,\n    'L': 4.03,\n    'C': 2.78,\n    'U': 2.76,\n    'M': 2.41,\n    'W': 2.36,\n    'F': 2.23,\n    'G': 2.02,\n    'Y': 1.97,\n    'P': 1.93,\n    'B': 1.49,\n    'V': 0.98,\n    'K': 0.77,\n    'J': 0.15,\n    'X': 0.15,\n    'Q': 0.10,\n    'Z': 0.07\n}\n\ndf = pd.DataFrame.from_dict([standard_frequency, frequency_revelation])\ndf.index = ['Standard Frequency', 'Revelation Frequency']\ndft = df.T\ndft = dft.sort_index()\ndft['Standard Frequency'] = dft['Standard Frequency'].astype(float)\ndft['Revelation Frequency'] = dft['Revelation Frequency'].astype(float)\n\n# --- Erstellen Sie das Side-by-Side-Balkendiagramm ---\n# Legen Sie die Breite der Balken fest\nbar_width = 0.35\n\n# Verwenden Sie den Index des transponierten DataFrames (dft)\nx = np.arange(len(dft.index))\n\nfig, ax = plt.subplots(figsize=(12, 7))\n\n# Zeichnen Sie die Balken für die beiden Spalten aus dft\nax.bar(x - bar_width/2, dft['Standard Frequency'], bar_width, label='Standard Frequency')\nax.bar(x + bar_width/2, dft['Revelation Frequency'], bar_width, label='Revelation Frequency')\n\nax.set_xticks(x)\nax.set_xticklabels(dft.index)\n\nax.set_xlabel('Letters')\nax.set_ylabel('Frequency (%)')\nax.set_title('Comparison of Letter Frequencies')\nax.legend()\nplt.tight_layout()\n\nplt.show()\n\n\n\n\n\n\n\n\n\nThe graphic shows that for a text length of 57,891 letters, the distribution in a literary text is almost identical to the general frequency distribution in the English language.\nThe following graphic shows what happens to the distribution of letters when the same text is encrypted with a Caesar cipher.\n\n\nCode\ndef caesar(text : str, shift : int, encrypt=True) -&gt; str:\n    text = text.upper()\n    result = \"\"\n    \n    if encrypt:\n        for char in text:\n            shifted = (ord(char) - ord('A') + shift) % 26 + ord('A')\n            result += chr(shifted)\n    else:\n        for char in text:\n            shifted = (ord(char) - ord('A') - shift) % 26 + ord('A')\n            result += chr(shifted)\n            \n    return result\n\n\nciphered_revelation = caesar(cleaned_revelation, 6, encrypt=True)\nfrequency_enyrpyted_revelation = letter_frequency(ciphered_revelation)\ndft['Revelation Frequency Encrypted'] = pd.Series(frequency_enyrpyted_revelation)\n\n# --- Erstellen Sie das Side-by-Side-Balkendiagramm ---\n# Legen Sie die Breite der Balken fest\nbar_width = 0.35\n\n# Verwenden Sie den Index des transponierten DataFrames (dft)\nx = np.arange(len(dft.index))\n\nfig, ax = plt.subplots(figsize=(12, 7))\n\n# Zeichnen Sie die Balken für die beiden Spalten aus dft\nax.bar(x - bar_width/2, dft['Standard Frequency'], bar_width, label='Standard Frequency')\nax.bar(x + bar_width/2, dft['Revelation Frequency Encrypted'], bar_width, label='Revelation Frequency Encrypted')\n\nax.set_xticks(x)\nax.set_xticklabels(dft.index)\n\nax.set_xlabel('Letters')\nax.set_ylabel('Frequency (%)')\nax.set_title('Comparison of Letter Frequencies of the Encrypted Text')\nax.legend()\nplt.tight_layout()\n\nplt.show()\n\n\n\n\n\n\n\n\n\nIt is clearly visible that the distribution follows the same pattern - shifted by six positions. This analysis allows the decryption of the text without having to try all possible key alphabets."
  },
  {
    "objectID": "files/lektionen_hs25/250917_vigenre/vigenere.html#weaknesses-of-monoalphabetic-ciphers",
    "href": "files/lektionen_hs25/250917_vigenre/vigenere.html#weaknesses-of-monoalphabetic-ciphers",
    "title": "9 Polyalphabetic Ciphers",
    "section": "",
    "text": "As early as the 9th century, the great weakness of monoalphabetic ciphers (Caesar cipher) was recognized in the Islamic world. The distribution of letters follows a specific but constant pattern in every language. As explained in the last section, the letter ‘e’ is by far the most common letter in the English language.\nTo demonstrate that this applies to any given (longer) texts, the text of the  Book of Revelations from the King James Bible  was analyzed. The resulting distribution of letters was plotted against the distribution from the table. The result is shown in the figure below.\n\n\nCode\nimport string\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef file_reader(path : str) -&gt; str:\n\n    with open(path, mode='r', encoding='utf-8') as f:\n        text = f.read()\n\n    return text\n\ndef text_cleaning(text : str) -&gt; str:\n    clean = text.upper() \\\n                .replace('Ä', 'AE') \\\n                .replace('Ö', 'OE') \\\n                .replace('Ü', 'UE') \\\n                .replace('ß', 'SS') \\\n                .replace(' ', '') \\\n\n    cleaned_text = ''\n\n    for c in clean:\n        if c.isalpha():\n            cleaned_text += c\n    \n    return cleaned_text\n\ndef file_writer(path : str, text : str) -&gt; None:\n    i = 0\n    grouped_text = \"\"\n    for c in text:\n        i += 1\n        if i % 50 == 0:\n            grouped_text += c + \"\\n\"\n        elif i % 5 == 0:\n            grouped_text += c + \" \"\n        else:\n            grouped_text += c\n        \n    with open(path, mode='w', encoding='utf-8') as f:\n        f.write(grouped_text)\n        \nrevelation = file_reader('revelation.txt')\ncleaned_revelation = text_cleaning(revelation)\nfile_writer('cleaned_revelation.txt', cleaned_revelation)\n\ndef letter_frequency(text: str) -&gt; dict:\n    frequency = {}\n    total_letters = 0\n    \n    for char in text:\n        if char not in frequency:\n            frequency[char] = 1\n        else:\n            frequency[char] += 1\n        total_letters += 1\n        \n    for key, value in frequency.items():\n        frequency[key] = (value / total_letters) * 100\n        \n           \n    return frequency\n\nfrequency_revelation = letter_frequency(cleaned_revelation)\n\n\nstandard_frequency = {\n    'E': 12.02,\n    'T': 9.10,\n    'A': 8.12,\n    'O': 7.68,\n    'I': 7.31,\n    'N': 6.95,\n    'S': 6.28,\n    'R': 6.02,\n    'H': 5.92,\n    'D': 4.32,\n    'L': 4.03,\n    'C': 2.78,\n    'U': 2.76,\n    'M': 2.41,\n    'W': 2.36,\n    'F': 2.23,\n    'G': 2.02,\n    'Y': 1.97,\n    'P': 1.93,\n    'B': 1.49,\n    'V': 0.98,\n    'K': 0.77,\n    'J': 0.15,\n    'X': 0.15,\n    'Q': 0.10,\n    'Z': 0.07\n}\n\ndf = pd.DataFrame.from_dict([standard_frequency, frequency_revelation])\ndf.index = ['Standard Frequency', 'Revelation Frequency']\ndft = df.T\ndft = dft.sort_index()\ndft['Standard Frequency'] = dft['Standard Frequency'].astype(float)\ndft['Revelation Frequency'] = dft['Revelation Frequency'].astype(float)\n\n# --- Erstellen Sie das Side-by-Side-Balkendiagramm ---\n# Legen Sie die Breite der Balken fest\nbar_width = 0.35\n\n# Verwenden Sie den Index des transponierten DataFrames (dft)\nx = np.arange(len(dft.index))\n\nfig, ax = plt.subplots(figsize=(12, 7))\n\n# Zeichnen Sie die Balken für die beiden Spalten aus dft\nax.bar(x - bar_width/2, dft['Standard Frequency'], bar_width, label='Standard Frequency')\nax.bar(x + bar_width/2, dft['Revelation Frequency'], bar_width, label='Revelation Frequency')\n\nax.set_xticks(x)\nax.set_xticklabels(dft.index)\n\nax.set_xlabel('Letters')\nax.set_ylabel('Frequency (%)')\nax.set_title('Comparison of Letter Frequencies')\nax.legend()\nplt.tight_layout()\n\nplt.show()\n\n\n\n\n\n\n\n\n\nThe graphic shows that for a text length of 57,891 letters, the distribution in a literary text is almost identical to the general frequency distribution in the English language.\nThe following graphic shows what happens to the distribution of letters when the same text is encrypted with a Caesar cipher.\n\n\nCode\ndef caesar(text : str, shift : int, encrypt=True) -&gt; str:\n    text = text.upper()\n    result = \"\"\n    \n    if encrypt:\n        for char in text:\n            shifted = (ord(char) - ord('A') + shift) % 26 + ord('A')\n            result += chr(shifted)\n    else:\n        for char in text:\n            shifted = (ord(char) - ord('A') - shift) % 26 + ord('A')\n            result += chr(shifted)\n            \n    return result\n\n\nciphered_revelation = caesar(cleaned_revelation, 6, encrypt=True)\nfrequency_enyrpyted_revelation = letter_frequency(ciphered_revelation)\ndft['Revelation Frequency Encrypted'] = pd.Series(frequency_enyrpyted_revelation)\n\n# --- Erstellen Sie das Side-by-Side-Balkendiagramm ---\n# Legen Sie die Breite der Balken fest\nbar_width = 0.35\n\n# Verwenden Sie den Index des transponierten DataFrames (dft)\nx = np.arange(len(dft.index))\n\nfig, ax = plt.subplots(figsize=(12, 7))\n\n# Zeichnen Sie die Balken für die beiden Spalten aus dft\nax.bar(x - bar_width/2, dft['Standard Frequency'], bar_width, label='Standard Frequency')\nax.bar(x + bar_width/2, dft['Revelation Frequency Encrypted'], bar_width, label='Revelation Frequency Encrypted')\n\nax.set_xticks(x)\nax.set_xticklabels(dft.index)\n\nax.set_xlabel('Letters')\nax.set_ylabel('Frequency (%)')\nax.set_title('Comparison of Letter Frequencies of the Encrypted Text')\nax.legend()\nplt.tight_layout()\n\nplt.show()\n\n\n\n\n\n\n\n\n\nIt is clearly visible that the distribution follows the same pattern - shifted by six positions. This analysis allows the decryption of the text without having to try all possible key alphabets."
  },
  {
    "objectID": "files/lektionen_hs25/250917_vigenre/vigenere.html#vigenère-chiffre",
    "href": "files/lektionen_hs25/250917_vigenre/vigenere.html#vigenère-chiffre",
    "title": "9 Polyalphabetic Ciphers",
    "section": "Vigenère Chiffre",
    "text": "Vigenère Chiffre\nThe Vigenère Cipher is a polyalphabetic cipher. The method is named after Blaise de Vigenère (1523 - 1596). Polyalphabetic means that not one shift is used for encryption, but - changing after each letter - several shifts are used.\nTo achieve this, a so-called Vigenère square is used as shown below.\n\nTo encrypt a plaintext, the Vigenère method requires a keyword. The keyword should be as long as possible. The following example is intended to show how the Vigenère method works. The plaintext to be encrypted is ‘Cryptology is amazing’ and the key is ‘Buelrain’.\nAs an aid, text and key are presented in a table.\ncryptologyisamazing\nbuelrainbuelrainbue\nThe key is repeated without spaces until the letter sequence of the key is as long as the letter sequence to be encrypted.\nNext the letter to be encrypted is searched in the header of the Vigenère square. This identifies the column with the shifted alphabet. The encrypted letter is obtained by searching in the column with the row headers the letter of the key located under the letter to be encrypted. The intersection of the row with the previously found column corresponds to the encrypted letter.\ncryptologyisamazing\nbuelrainbuelrainbue\n\nDLCAKOTBHSMDRMIMJHR\nOn a computer, the Vigenère cipher can be implemented by using modular arithmetic. To do this, each letter is assigned a numerical value according to the pattern \\(a = 0, b = 1, ... , z = 25\\). The encryption is then performed according to the ‘formula’ \\(C_i = (P_i + K_i)\\ mod\\ 26\\) where the letters \\(C\\) stand for the ciphertext, \\(P\\) for the plaintext and \\(K\\) for the key. The index \\(_i\\) stands for the \\(i\\)-th letter in the text sequence.\nThe example above can be illustrated as follows.\n c  r  y  p  t  o  l  o  g  i  e  s  a  m  a  z  i  n  g\n02 17 24 15 19 14 11 14 06 08 04 18 00 12 00 25 08 13 06\n b  u  e  l  r  a  i  n  b  u  e  l  r  a  i  n  b  u  e\n01 20 04 11 17 00 08 13 01 20 04 11 17 00 08 13 01 20 04\n\n03 37 28 26 36 14 19 27 07 28 08 29 17 12 08 38 09 33 10\n\n03 11 02 00 10 14 19 01 07 02 08 19 09 19 00 02 01 07 17\n D  L  C  A  K  O  T  B  H  C  I  T  J  T  A  C  B  H  R\nFor decryption, the same formula can be used, but with a minus instead of a plus (\\(P_i = (C_i - K_i + 26)\\ mod\\ 26\\)). The addition of 26 in the brackets is used to avoid negative numbers.\nHow the Vigenère cipher affects the distribution of letters can be seen in the graphic below.\n\n\nCode\ndef vigenere_chiffre(text: str, key: str, encrypt=True) -&gt; str:\n    \"\"\"\n    Implementiert die Vigenère-Verschlüsselung für einen gegebenen Klartext und\n    Schlüssel.\n    \n    Args:\n        klartext (str): Der zu verschlüsselnde Text schluessel (str): Das\n        Schlüsselwort für die Verschlüsselung\n    \n    Returns:\n        str: Der verschlüsselte Text\n    \"\"\"\n    \n    # initialisiere den resultierenden Text\n    resulting_text = ''\n    \n    # bestimme die Schlüssellänge für die anschliessende Modulo-Operation\n    key_length = len(key)\n    \n    # itererie über den Eingabetext unter gleichzeitiger Erfassung des Index\n    for i, char in enumerate(text):\n        # berechne den Zahlwert des Buchstabens aus der ascii Tabelle\n        char_no = ord(char) - 97\n        key_no = ord(key[i % key_length]) - 97\n        \n        if encrypt == True:\n            # berechne den Zahlwert des verschlüsselten Buchstabens\n            ciph_no = (char_no + key_no) % 26\n        else:\n            # berechne den Zahlwert des entschlüsselten Buchstabens\n            ciph_no = (char_no + (26 - key_no)) % 26\n            \n         # übernehme das Zeichen aufgrund seines Zahlwertes aus der ascii Tabelle  \n        ciph = chr(ciph_no + 97)\n        \n        # füge den Buchstaben am resultierenden Text an\n        resulting_text += ciph\n    return resulting_text\n\nrevelation_vigenere = vigenere_chiffre(cleaned_revelation.lower(), 'buelrain', encrypt=True)\n\nrevelation_vigenere_frequency = letter_frequency(revelation_vigenere.upper())\ndft['Revelation Frequency Vigenere'] = pd.Series(revelation_vigenere_frequency)\n\n# --- Erstellen Sie das Side-by-Side-Balkendiagramm ---\n# Legen Sie die Breite der Balken fest\nbar_width = 0.35\n\n# Verwenden Sie den Index des transponierten DataFrames (dft)\nx = np.arange(len(dft.index))\n\nfig, ax = plt.subplots(figsize=(12, 7))\n\n# Zeichnen Sie die Balken für die beiden Spalten aus dft\nax.bar(x - bar_width/2, dft['Standard Frequency'], bar_width, label='Standard Frequency')\nax.bar(x + bar_width/2, dft['Revelation Frequency Vigenere'], bar_width, label='Revelation Frequency Vigenère')\n\nax.set_xticks(x)\nax.set_xticklabels(dft.index)\n\nax.set_xlabel('Letters')\nax.set_ylabel('Frequency (%)')\nax.set_title('Comparison of Letter Frequencies of the Vigenère Encrypted Text')\nax.legend()\nplt.tight_layout()\n\nplt.show()\n\n\n\n\n\n\n\n\n\nIt is quite obvious that the distribution of letters in a polyalphabetically encrypted text is significantly different from that in normal text. The Vigenère cipher was therefore considered ‘la chiffre indéchiffrable’ for about 300 years.\nHowever, a special case of the Vigenère cipher is actually not decipherable. This is the case when the key is longer than the plaintext. This is called the “One-Time Pad”."
  },
  {
    "objectID": "files/lektionen_hs25/250910/caesar_chiffre.html",
    "href": "files/lektionen_hs25/250910/caesar_chiffre.html",
    "title": "8 Caesar Cipher",
    "section": "",
    "text": "In cryptography, encryption is the process of transforming information in a way that, ideally, only authorised parties can decode. This process converts the original representation of the information, known as plaintext, into an alternative form known as ciphertext. Despite its goal, encryption does not itself prevent interference but denies the intelligible content to a would-be interceptor.\nFrom Wikipedia\nThe first example of a cipher we will look at is the Caesar cipher.\nThe Caesar cipher is a simple substitution encryption technique in which each letter of the text to be encrypted is replaced by a letter a fixed number of positions away in the alphabet. For example, using a right letter shift of four, A would be replaced by E, and the word CIPHER would become GMTLIV. The technique is named after Julius Caesar, who used it in his letters. The simplicity of the Caesar cipher makes it a popular source for recreational cryptograms.\nFrom Encyclopedia Britannica"
  },
  {
    "objectID": "files/lektionen_hs25/250910/caesar_chiffre.html#python-implementation",
    "href": "files/lektionen_hs25/250910/caesar_chiffre.html#python-implementation",
    "title": "8 Caesar Cipher",
    "section": "Python Implementation",
    "text": "Python Implementation\nTo implement the Caesar cipher in Python, we build on the string methods offered by Python. The ord function returns the  Unicode  code point for a given character, and the chr function returns the character that corresponds to a given Unicode code point.\n\n# What is the Unicode code point of the character 'A'?\n\n\nSimple (naïve) Implementation\nFirst, we define a function that encrypts a given plaintext by shifting each letter by a specified number of positions in the alphabet.\n\nplain = \"CIPHER\"\nshift = 4\n\n\ndef caesar_encode(plain, shift):\n    cipher = \"\"\n    \n    for char in plain:\n        shifted = ord(char) + shift\n        cipher += chr(shifted)\n        \n    return cipher\n\n\n\nEnhanced Implementation\nBut what happens if we reach the end of the alphabet? For example, if we shift Z by 4 positions, we would go past Z. To handle this, we can use the modulo operator % to wrap around the alphabet. The modulo operator gives the remainder of a division operation, which allows us to “wrap around” when we exceed the length of the alphabet. In the case of the Caesar cipher, we can use it to ensure that our shifted positions stay within the bounds of the alphabet.\nTherefore, we will use modulo 26 (the number of letters in the English alphabet) to ensure that our shifted positions wrap around correctly. For example, if we shift Z by 4 positions, we would end up at D. This wrapping behaviour is essential for the Caesar cipher to function correctly.\nThe calculation for the new position of a letter can be expressed as:\n\\[\nx' = (x + n) \\mod 26\n\\]\nor, in another notation:\n\\[\nx' = x \\oplus_{26} n\n\\]\nLet’s implement this in Python:\n\ndef caesar_encrypt_mod(plain, shift):\n    cipher = \"\"\n    \n    for char in plain:\n        shifted = (ord(char) - ord('A') + shift) % 26 + ord('A')\n        cipher += chr(shifted)\n        \n    return cipher\n\nBecause\nord('A')\nreturns 65, we need to subtract 65 from the result of ord('A') to get 0. This gives us the 0-based index of the letter in the alphabet, which is useful for our calculations.\nHence the calculation shown above.\nFor the decryption, we can simply subtract the shift value instead of adding it:\n\ndef caesar_decrypt_mod(plain, shift):\n    cipher = \"\"\n    \n    for char in plain:\n        shifted = (ord(char) - ord('A') - shift) % 26 + ord('A')\n        cipher += chr(shifted)\n        \n    return cipher\n\nFor convenience, we implement one function for both encryption and decryption.\n\ndef caesar(text : str, shift : int, encrypt=True) -&gt; str:\n    text = text.upper()\n    result = \"\"\n    \n    if encrypt:\n        for char in text:\n            shifted = (ord(char) - ord('A') + shift) % 26 + ord('A')\n            result += chr(shifted)\n    else:\n        for char in text:\n            shifted = (ord(char) - ord('A') - shift) % 26 + ord('A')\n            result += chr(shifted)\n            \n    return result"
  },
  {
    "objectID": "files/lektionen_hs25/250910/caesar_chiffre.html#breaking-caesar-cipher",
    "href": "files/lektionen_hs25/250910/caesar_chiffre.html#breaking-caesar-cipher",
    "title": "8 Caesar Cipher",
    "section": "Breaking Caesar Cipher",
    "text": "Breaking Caesar Cipher\nThere are two main methods to break a Caesar cipher: 1. Brute Force Attack: Try all possible shifts (1-25) and see which one produces a meaningful result. 2. Frequency Analysis: Analyse the frequency of letters in the ciphertext and compare it to the expected frequency of letters in the language.\n\nBrute Force Attack\n\ndef caesar_bruteforce(ciphertext: str) -&gt; None:\n    for shift in range(1, 26):\n        decrypted_text = caesar(ciphertext, shift, encrypt=False)\n        print(f\"Shift {shift}: {decrypted_text}\")\n\n\n\nFrequency Analysis\nIn the English language, certain letters appear more frequently than others. For example, the letter ‘E’ is the most common letter in English text, followed by ‘T’, ‘A’, ‘O’, ‘I’, and ‘N’. By analysing the frequency of letters in the ciphertext, we can make educated guesses about which letters correspond to which in the plaintext.\nFor a more accurate analysis, see the following frequency table:\n\n\n\nLetter\nFrequency\n\n\n\n\nE\n12.02%\n\n\nT\n9.10%\n\n\nA\n8.12%\n\n\nO\n7.68%\n\n\nI\n7.31%\n\n\nN\n6.95%\n\n\nS\n6.28%\n\n\nR\n6.02%\n\n\nH\n5.92%\n\n\nD\n4.32%\n\n\nL\n4.03%\n\n\nC\n2.78%\n\n\nU\n2.76%\n\n\nM\n2.41%\n\n\nW\n2.36%\n\n\nF\n2.23%\n\n\nG\n2.02%\n\n\nY\n1.97%\n\n\nP\n1.93%\n\n\nB\n1.49%\n\n\nV\n0.98%\n\n\nK\n0.77%\n\n\nJ\n0.15%\n\n\nX\n0.15%\n\n\nQ\n0.10%\n\n\nZ\n0.07%\n\n\n\nTherefore, we need a function that counts the frequency of each letter in the ciphertext. The result should be a dictionary where the keys are the letters and the values are the counts of each letter. Or even better, the frequencies in percent.\nTo keep things simple, we assume that the input text only contains uppercase letters from A to Z and no spaces or punctuation.\n\ndef letter_frequency(text: str) -&gt; dict:\n    frequency = {}\n    total_letters = 0\n    \n    for char in text:\n        if char not in frequency:\n            frequency[char] = 1\n        else:\n            frequency[char] += 1\n        total_letters += 1\n        \n    for key, value in frequency.items():\n        frequency[key] = (value / total_letters) * 100\n        \n           \n    return frequency\n\nAfter finding the most frequent letter in the ciphertext, we can assume that it corresponds to the letter ‘E’ in the plaintext. By calculating the shift needed to convert the most frequent letter to ‘E’, we can then decrypt the entire ciphertext using that shift value.\n\ndef find_shift(char: str, e = 'E') -&gt; int:\n    return (ord(char) - ord(e)) % 26\n\nAfter guessing the shift, we can use our existing caesar function to decrypt the ciphertext. We can call the function with the encrypted text and the guessed shift value to obtain the original plaintext.\nIf needed, the implementation of the find_shift function can exchange the default value for the most frequent letter to another letter."
  },
  {
    "objectID": "files/lektionen_hs25/250827/three_way_handshake.html",
    "href": "files/lektionen_hs25/250827/three_way_handshake.html",
    "title": "5 Monitoring Internet connections",
    "section": "",
    "text": "The following explanations are based on the analysis of network packets recorded with Wireshark. This requires the installation of Wireshark. The  Wireshark website provides the corresponding download."
  },
  {
    "objectID": "files/lektionen_hs25/250827/three_way_handshake.html#recording-network-packets",
    "href": "files/lektionen_hs25/250827/three_way_handshake.html#recording-network-packets",
    "title": "5 Monitoring Internet connections",
    "section": "Recording network packets",
    "text": "Recording network packets\nTo record network packets, start Wireshark. The Wireshark start window looks like this:\n\n\n\nWireshark start window\n\n\nUnder the heading ‘Capture’, you can select the desired network adapter and start recording. The captured packets are displayed in real time and can be analysed later. At school, the connection to the Internet is established via WLAN. The WLAN adapter must be selected accordingly. Once the appropriate adapter has been selected, recording can be started. Recording is started by clicking on the blue shark fin icon in the toolbar. Recording starts immediately. Recording is paused by clicking on the red square icon in the toolbar. The recording can be saved either via the File &gt; Save menu, by clicking on the file icon or by using the key combination Ctrl + S."
  },
  {
    "objectID": "files/lektionen_hs25/250827/three_way_handshake.html#monitoring-dns-requests",
    "href": "files/lektionen_hs25/250827/three_way_handshake.html#monitoring-dns-requests",
    "title": "5 Monitoring Internet connections",
    "section": "Monitoring DNS requests",
    "text": "Monitoring DNS requests\n\nFiltering the recording\nTo monitor DNS requests, any website is called up while Wireshark recording is running. This captures the corresponding DNS requests, which can then be analysed in Wireshark. After calling up the website, the recording can be paused and the captured packets analysed (if the recording continues, the packets in the display window continue to move).\nTo display the relevant data packets, the recorded data traffic can be filtered. The filter is entered in the input field for ‘Display filter’.\n\n\n\nWireshark display filter\n\n\nThe corresponding filter for DNS queries to a given website is\ndns.qry.name == \"www.example.com\"\nThe filter command used is relatively easy to understand. The first thing to note here is the protocol being filtered. Because the filtering is based on DNS queries, this is dns. dns alone would already be a valid filter. However, this would then display all DNS packets . The filter is therefore supplemented to dns.qry.name, where qry is short for query. The addition name stands for the domain name that is being queried. == is the logical operator used for filtering and means ‘is equal to’ in this case. The string being searched for is between the quotation marks. If the page was accessed exactly once during recording, the filter will display two packets: one DNS query and one DNS response. If the page was accessed multiple times during recording, the filter will display multiple packets.\n\n\n\nFiltered Wireshark packets\n\n\nThe image shows the DNS query for www.deutschegrammaphon.com as the first packet and the corresponding response as the second packet.\n\n\nAnalysis of the filtered packets\nFor a detailed analysis of the communication, a single packet can be selected by clicking on it. This will display the packet in the lower area of Wireshark in detail and it can be examined more closely.\n\n\n\nContent of the selected packet\n\n\nThat it is the details of the selected packet that are shown in the image is evident from the matching packet number. The lines in the detail view correspond to the individual protocol header fields of the selected packet. This also reflects the TCP/IP layering model.\nThe detail view can be expanded by clicking on the triangles at the beginning of the individual protocol header fields. This will display further information about the respective fields. However, only the summaries of the header fields are explained here.\nIn this example, the content of the Internet layer header is explained first.\n\nInternet Protocol Version 4, Src: 192.168.1.108, Dst: 192.168.1.1\nIn the summary, the source and destination addresses of the IP packet are displayed. In this case, these are the private IP addresses 192.168.1.108 and 192.168.1.1. 192.168.1.108 is the source address, identifiable by the abbreviation “Src”, and 192.168.1.1 is the destination address, identifiable by the abbreviation “Dst”. Both devices are thus located in the same LAN. The computer with the IP address 192.168.1.1 is the router. This device establishes the Internet connection and can answer DNS queries from its cache.\nIn the header for the User Datagram Protocol (UDP), the source and destination ports are displayed.\nUser Datagram Protocol, Src Port: 53586, Dst Port: 53\nThe source port was automatically chosen as 53586, well above the so-called “Well-Known Ports” (0-1023). The “Well-Known Ports” are ports that are used by certain applications or services by default. Accordingly, the destination port was set to 53, as this is the default port for DNS queries. A list of “Well-Known Ports” can be found in the  official IANA port database. The source port allows the destination system to send the response back to the correct sender.\nNAT devices (see Section Network Address Translation (NAT)) use this port information for the mapping between private and public addresses.\nThe layer displayed at the bottom of the detail view contains the actual request for the translation of the domain name into an IP address.\nDomain Name System (query)\n    Transaction ID: 0x1f7a\n    Flags: 0x0100 Standard query\n    Questions: 1\n    Answer RRs: 0\n    Authority RRs: 0\n    Additional RRs: 0\n    Queries\n        www.deutschegrammophon.com: type A, class IN\n    [Response In: 723]\nFor this reason, this part of the analysis is also unfolded here. Under the keyword Queries, the requested address www.deutschegrammophon.com is displayed. The keyword type A indicates that this is a request for an IPv4 address. IPv4 addresses are designated with A, while IPv6 addresses are designated with AAAA. The last element in this line is the class of the request, in this case IN for the Internet. Although today almost exclusively the Internet is used as a network type, the field for the class (IN) is still part of every DNS request for historical reasons.\nThe corresponding content of the response looks as follows:\nDomain Name System (response)\n    Transaction ID: 0x1f7a\n    Flags: 0x8180 Standard query response, No error\n    Questions: 1\n    Answer RRs: 1\n    Authority RRs: 0\n    Additional RRs: 0\n    Queries\n        www.deutschegrammophon.com: type A, class IN\n    Answers\n        www.deutschegrammophon.com: type A, class IN, addr 85.236.46.65\nThe packet repeats the question and provides the answer from the DNS server. The domain name www.deutschegrammophon.com is associated with the IPv4 address 85.236.46.65.\nThis allows the connection to the website www.deutschegrammophon.com to be established."
  },
  {
    "objectID": "files/lektionen_hs25/250827/three_way_handshake.html#monitoring-of-the-connection-establishment",
    "href": "files/lektionen_hs25/250827/three_way_handshake.html#monitoring-of-the-connection-establishment",
    "title": "5 Monitoring Internet connections",
    "section": "Monitoring of the Connection Establishment",
    "text": "Monitoring of the Connection Establishment\nThe connection establishment between the client (local computer) and the server (computer on the Internet) takes place in several steps, which are summarized in the so-called “Three-Way Handshake”. This process ensures that both sides are ready to send and receive data.\nThe following illustration shows a schematic representation of the “Three-Way Handshake”.\n\n\n\nScheme Three-Way Handshake\n\n\nThe client sends a SYN packet to the server to request a connection. The server responds with a SYN-ACK packet. This means it acknowledges the request with an ACK and inquires with a SYN whether the client is (still) ready to establish the connection. To make it clear that the ACK in the SYN-ACK packet refers to the original SYN packet, the individual packets are assigned a sequence number. The ACK returns the sequence number of the SYN packet plus one.\nThis process can be observed with Wireshark. For this, a combined Wireshark display filter is needed. As an example, the connection establishment between the local computer and the website of www.deutschegrammophon.com is considered. The first part of the filter should only display those packets that communicate with the IP address of the server of www.deutschegrammophon.com (85.236.46.65). This filter is\nip.addr == 85.236.46.65\nThis sole filter, however, still shows too many packets.\n\n\n\nip.addr filter\n\n\nTo further narrow down the results, only those packets should be displayed that have either the SYN flag or the ACK flag (or both) set. This can be achieved with the following filter:\nip.addr == 85.236.46.65 and \n  (tcp.flags.syn == 1 or tcp.flags.ack == 1 )\nStill, this shows way too many packets. Therefore, only those packets should be displayed that are the responses to a SYN request. This can be achieved by right-clicking on a packet with the SYN flag and selecting the “Follow” &gt; “TCP Stream” option. This will display the entire TCP stream in which this packet is located (the consecutive packets). The filter will be automatically adjusted.\nThe following listing shows the entire filter command for displaying the packets belonging to this TCP stream:\nip.addr == 85.236.46.65 and \n  (tcp.flags.syn == 1 or tcp.flags.ack == 1) and\n  !(tcp.stream eq 8)\n\n\n\nThree-way handshake packets\n\n\nThat the packets show the communication sequence of the Three-Way Handshake can be seen from the set flags. In the first step, the client sends a SYN packet, to which the server responds with a SYN-ACK packet. The client confirms this with an ACK packet. These three steps are visible in the Wireshark filter. The respective port numbers used in the TCP packets are clearly recognizable.\nFollowing this “Three-Way Handshake”, the client can communicate with the server."
  },
  {
    "objectID": "files/lektionen_hs25/250820/tcpip.html",
    "href": "files/lektionen_hs25/250820/tcpip.html",
    "title": "2 IP Addresses and DNS",
    "section": "",
    "text": "For computers to be accessible within a network, they need a unique address. This address is known as an IP address (Internet Protocol Address). For around two decades now, – there has been a gradual transition from the IPv4 system to IPv6. IPv4 addresses are 32-bit addresses represented in four octets (e.g. 192.0.2.1). This results in \\(2^{32}\\) possible addresses, which is slightly more than 4.29 billion. This demonstrates the limited nature of IPv4 addresses. This limitation led to the development of IPv6. IPv6 addresses are 128 bits long. They are displayed in hexadecimal notation, with eight groups of four hexadecimal digits (e.g.  2001:0db8:85a3:0000:0000:8a2e:370:7334). The length of 128 bits allows for \\(2^{128}\\) addresses, which in decimal notation corresponds to \\(3.4\n\\times 10^{38}\\), a number with 39 digits. There would be approximately \\(6.7 \\cdot 10^{23}\\) IPv6 addresses per square metre of the Earth’s surface - that is roughly one  Avogadro number per square metre."
  },
  {
    "objectID": "files/lektionen_hs25/250820/tcpip.html#ip-addresses",
    "href": "files/lektionen_hs25/250820/tcpip.html#ip-addresses",
    "title": "2 IP Addresses and DNS",
    "section": "",
    "text": "For computers to be accessible within a network, they need a unique address. This address is known as an IP address (Internet Protocol Address). For around two decades now, – there has been a gradual transition from the IPv4 system to IPv6. IPv4 addresses are 32-bit addresses represented in four octets (e.g. 192.0.2.1). This results in \\(2^{32}\\) possible addresses, which is slightly more than 4.29 billion. This demonstrates the limited nature of IPv4 addresses. This limitation led to the development of IPv6. IPv6 addresses are 128 bits long. They are displayed in hexadecimal notation, with eight groups of four hexadecimal digits (e.g.  2001:0db8:85a3:0000:0000:8a2e:370:7334). The length of 128 bits allows for \\(2^{128}\\) addresses, which in decimal notation corresponds to \\(3.4\n\\times 10^{38}\\), a number with 39 digits. There would be approximately \\(6.7 \\cdot 10^{23}\\) IPv6 addresses per square metre of the Earth’s surface - that is roughly one  Avogadro number per square metre."
  },
  {
    "objectID": "files/lektionen_hs25/250820/tcpip.html#dns-lookup",
    "href": "files/lektionen_hs25/250820/tcpip.html#dns-lookup",
    "title": "2 IP Addresses and DNS",
    "section": "DNS Lookup",
    "text": "DNS Lookup\nPeople find it difficult to remember IP addresses. Therefore, domain names were introduced, which are easier to remember. An example of a domain name is www.google.com. A possible IP address for Google’s domain name is 172.217.168.68; often there are several IP addresses for a domain name. The Domain Name System (DNS) is responsible for ‘translating’ a domain name into an IP address.\n\nHow it works\n\nRequest: When a user visits a website, the browser sends a DNS request to a DNS server to determine the IP address of the desired domain.\nResolution: The DNS server checks its cache for an existing assignment. If no assignment is found, the server forwards the request to other DNS servers until the IP address is determined.\nResponse: The DNS server sends the IP address it found back to the browser, which can then connect to the website.\n\n\n\nTypes of DNS records\n\nA record: Links a domain name to an IPv4 address.\nAAAA record: Links a domain name to an IPv6 address.\nCNAME record: Alias for another domain name.\nMX record: Specifies the mail server for a domain.\n\n\n\nSignificance\nThe domain name is crucial for the user-friendliness of the Internet, as it allows websites to be accessed via easy-to-remember names instead of numerical IP addresses. Without DNS, users would have to know the IP addresses of all the websites they want to visit."
  },
  {
    "objectID": "files/lektionen_hs25/250820/nat.html",
    "href": "files/lektionen_hs25/250820/nat.html",
    "title": "3 Network Address Translation (NAT)",
    "section": "",
    "text": "Network Address Translation (NAT) is a process for automatically and transparently translating IP addresses in data packets. NAT enables multiple devices in a private network to communicate with the Internet via a single public IP address. This technology was developed to address the scarcity of IPv4 addresses while increasing the security of private networks.\nIn practice, this means that if you connect multiple devices (laptop, smartphone, smart TV) to the Internet at home, all of these devices share a single public IP address assigned to you by your Internet service provider."
  },
  {
    "objectID": "files/lektionen_hs25/250820/nat.html#what-is-nat",
    "href": "files/lektionen_hs25/250820/nat.html#what-is-nat",
    "title": "3 Network Address Translation (NAT)",
    "section": "",
    "text": "Network Address Translation (NAT) is a process for automatically and transparently translating IP addresses in data packets. NAT enables multiple devices in a private network to communicate with the Internet via a single public IP address. This technology was developed to address the scarcity of IPv4 addresses while increasing the security of private networks.\nIn practice, this means that if you connect multiple devices (laptop, smartphone, smart TV) to the Internet at home, all of these devices share a single public IP address assigned to you by your Internet service provider."
  },
  {
    "objectID": "files/lektionen_hs25/250820/nat.html#how-nat-works",
    "href": "files/lektionen_hs25/250820/nat.html#how-nat-works",
    "title": "3 Network Address Translation (NAT)",
    "section": "How NAT works",
    "text": "How NAT works\n\nBasic principle\nNAT operates at layer 3 of the OSI model and changes the addresses in the IP header of data packets. The process works as follows:\n\nOutgoing connection: A device on the private network (e.g. 192.168.1.10) sends a request to a server on the Internet.\nAddress translation: The NAT router replaces the private source IP address with its public IP address (e.g. 203.0.113.5).\nTable entry: The router stores the assignment in a NAT table.\nResponse: When the server responds, the router uses the NAT table to forward the response to the correct device on the private network.\n\n\n\nNAT table\nThe NAT table is at the heart of the process. It contains the following information:\n\nPrivate IP address (e.g. 192.168.1.10)\nPrivate port (e.g. 54321)\nPublic IP address (e.g. 203.0.113.5)\nPublic port (e.g. 12345)\nDestination IP address (e.g. 93.184.216.34)\nDestination port (e.g. 80)"
  },
  {
    "objectID": "files/lektionen_hs25/250820/nat.html#private-ip-address-ranges",
    "href": "files/lektionen_hs25/250820/nat.html#private-ip-address-ranges",
    "title": "3 Network Address Translation (NAT)",
    "section": "Private IP address ranges",
    "text": "Private IP address ranges\nSpecial IP address ranges are reserved for private networks that are not routed on the public Internet:\n\n10.0.0.0 to 10.255.255.255 (10.0.0.0/8) – 16,777,216 addresses\n172.16.0.0 to 172.31.255.255 (172.16.0.0/12) – 1,048,576 addresses\n\n192.168.0.0 to 192.168.255.255 (192.168.0.0/16) – 65,536 addresses\n\nThese ranges can be reused as often as desired in private networks, as they are only valid locally."
  },
  {
    "objectID": "files/lektionen_hs25/250820/nat.html#types-of-nat",
    "href": "files/lektionen_hs25/250820/nat.html#types-of-nat",
    "title": "3 Network Address Translation (NAT)",
    "section": "Types of NAT",
    "text": "Types of NAT\n\n1. Static NAT (one-to-one NAT)\nWith static NAT, a private IP address is permanently assigned to a public IP address. This is used when a server in the private network needs to be permanently accessible from the Internet.\nExample: - Private: 192.168.1.100 ↔︎ Public: 203.0.113.10\n\n\n2. Dynamic NAT\nDynamic NAT dynamically assigns private IP addresses from a pool of public IP addresses. The assignment is made as needed and is released again after a certain period of time.\n\n\n3. Port Address Translation (PAT)\n\nWhat is a port?\nTo understand how PAT works, we first need to understand the concept of ports. An IP address identifies a computer on the network – but many programs run simultaneously on a computer, all of which want to use network connections.\nAnalogy: Imagine the IP address as the postal address of a high-rise building. The port number then corresponds to the apartment number. Just as the post office knows which apartment a letter belongs to, the computer knows which program the data should be delivered to based on the port number.\nPorts are 16-bit numbers (0 to 65,535) and are divided into three categories: - Well-known ports (0-1023): Reserved for standard services - Port 80: HTTP (websites) - Port 443: HTTPS (encrypted websites) - Port 22: SSH (secure connection) - Port 25: SMTP (email transmission) - Registered ports (1024-49,151): For registered services - Dynamic/private ports (49,152-65,535): Freely usable\n\n\nHow PAT works\nPAT, also known as NAT overload, is the most common form of NAT. Here, many private IP addresses share a single public IP address, with differentiation based on port numbers.\nThe router not only remembers which private IP address has established a connection, but also which port. This allows multiple devices to communicate simultaneously via the same public IP address.\nCalculation example: With 16-bit port numbers, \\(2^{16} = 65,536\\) ports are theoretically available. Minus the reserved ports (0-1023), this leaves approximately 64,512 usable ports for simultaneous connections. In practice, this means that a home router could theoretically manage over 64,000 simultaneous connections."
  },
  {
    "objectID": "files/lektionen_hs25/250820/nat.html#advantages-and-disadvantages",
    "href": "files/lektionen_hs25/250820/nat.html#advantages-and-disadvantages",
    "title": "3 Network Address Translation (NAT)",
    "section": "Advantages and disadvantages",
    "text": "Advantages and disadvantages\n\nAdvantages\n\nIP address savings: A household with 20 devices only needs one public IP address\nSecurity: Private IP addresses are not directly accessible from the outside\nFlexibility: The internal network structure can be changed without affecting the public address\n\n\n\nDisadvantages\n\nEnd-to-end connectivity: Direct connections between devices are made more difficult\nComplexity: Certain applications (e.g. VoIP, online gaming) require special configurations\nPerformance: Address translation requires computing power and can cause delays"
  },
  {
    "objectID": "files/lektionen_hs25/250820/nat.html#practical-example",
    "href": "files/lektionen_hs25/250820/nat.html#practical-example",
    "title": "3 Network Address Translation (NAT)",
    "section": "Practical example",
    "text": "Practical example\nLet’s consider a typical home router:\n\nYour laptop (192.168.1.15) opens the website www.example.com\nHTTP request:\n\nSource: 192.168.1.15:45678\nDestination: 93.184.216.34:80\n\nNAT router translates:\n\nSource: 85.5.123.45:23456 (public IP)\nDestination: 93.184.216.34:80\n\nServer responds:\n\nSource: 93.184.216.34:80\nDestination: 85.5.123.45:23456\n\nRouter translates back:\n\nSource: 93.184.216.34:80\nDestination: 192.168.1.15:45678"
  },
  {
    "objectID": "files/lektionen_hs25/250820/nat.html#significance-for-the-future",
    "href": "files/lektionen_hs25/250820/nat.html#significance-for-the-future",
    "title": "3 Network Address Translation (NAT)",
    "section": "Significance for the future",
    "text": "Significance for the future\nWith the introduction of IPv6 and its \\(2^{128}\\) possible addresses, NAT will theoretically become superfluous. In practice, however, NAT will continue to be used because:\n\nMany networks are still based on IPv4\nNAT provides additional security\nThe transition to IPv6 is taking place gradually\n\nNAT therefore remains an important technology for the modern Internet, solving both the address shortage and contributing to network security."
  },
  {
    "objectID": "files/lektionen_hs24/250115/binary_search_tree.html",
    "href": "files/lektionen_hs24/250115/binary_search_tree.html",
    "title": "Binary Search Tree",
    "section": "",
    "text": "Die bisher verwendete Python Listen sind sehr einfach zu bedienen. Allerdings verschleiern sie die zu Grunde liegende Datenstruktur.\nBei einer Python Liste handelt es sich um ein dynamisches Array. Ein Array ist eine Datenstruktur, bei der im Voraus ein zusammenhängender Speicherbereich von fixer Grösse definiert wird. Bei einem dynamischen Array fällt die Restriktion der fixierten Grösse weg und dem Speicherplatz wird laufend den Bedürfnissen angepasst. Die Anpassung der Grösse des Speicherbereichs ist allerdings mit erheblichem Rechenaufwand verbunden. Diesem Nachteil steht allerdings der Vorteil gegenüber, dass in einem Array mittels des Index mit konstantem Aufwand auf die einzelnen Elemente zugegriffen werden kann. Falls das Array sortiert ist, kann ausserdem relativ effizient nach einem Element in dieser Datenstruktur gesucht werden.\nEine Alternative für das Ablegen einer Sequenz von Elementen mit nicht im Voraus bestimmten Umfang, ist eine verkettete Liste (linked list).\nDie verkettete Liste (linked list) ist eine Datenstruktur, bei der mit einer Variabel auf das erste gespeicherte Element verwiesen wird. Zusammen mit diesem Element wird auch der Speicherort des nächsten Elementes gespeichert. Von dieser Verkettung von Element zu Element hat die Datenstruktur ihren Namen. In einer verketteten Liste lassen sich neue Elemente mit konstantem Aufwand einfügen. Allerdings hat die verkettete Liste den Nachteil, dass die Suche nach einem Element mit linearem Aufwand verbunden ist.\nAn dieser Stelle kommt der binäre Suchbaum (binary search tree, bst) ins Spiel.\n\nBäume in der Informatik\n\n\n\nQuelle: xkcd.com/835, besucht am 4. Mai 24\n\n\nEin Baum in der Informatik ist eine Datenstruktur die aus Knoten (engl. Vertex bzw. vertices, V) und Kanten (engl. edge, E) besteht. Der erste Knoten ist die Wurzel (engl. root). Alle anderen Knoten haben einen Knoten als Elternknoten. Ein Elternknoten kann ein oder mehrere Kindknoten haben. Ein Knoten ohne Kinder wird als Blatt bezeichnet. Üblicherweise werden Bäume vom Wurzelknoten aus nach unten dargestellt.\n\nEin binärer Suchbaum ist eine baumförmige Datenstruktur, bei der jeder Knoten ein oder zwei Kinder hat. Die Werte in den Knoten sind dabei so in den Baum eingeordnet, dass jedes linke Kind kleiner ist als der Elternknoten und jedes rechte Kind grösser. Im Idealfall ist der Baum symmetrisch ausbalanciert. Es kann allerdings auch sein, dass ein binärer Suchbaum derart aus dem Gleichgewicht ist, dass er wie eine verkettete Liste aussieht. Aus diesem Grund muss bei der Effizienzbetrachtung dieser Datenstruktur zwischen Idealfall und Worst Case unterschieden werden. Im Idealfall ist die Suche und das Einfügen neuer Elemente mit einem Aufwand von \\(log(n)\\) möglich. Im Worst Case verursacht die Suche einen linearen Aufwand.\nDie folgende Grafik zeigt ein Beispiel eines binären Suchbaums.\n\n\n\nBeispielbaum"
  },
  {
    "objectID": "files/lektionen_hs24/241211/schneeflocke.html",
    "href": "files/lektionen_hs24/241211/schneeflocke.html",
    "title": "Anwendungsübung zur Rekursion",
    "section": "",
    "text": "In diesem Notebook soll eine graphische Anwendung einer rekursiven Funktion implementiert werden. Als Grafiklibrary wird PyTamaro verwendet. In der folgenden Code Zelle werden die erforderlichen Funktionen geladen.\n\n# Import der erforderlichen PyTamaro Funktionen\nfrom pytamaro import (\n    rectangle, Graphic, Empty,\n    black,\n    pin, bottom_left, bottom_right, top_left, top_right, bottom_center,\n    rotate, graphic_height, overlay,\n    show_graphic, save_graphic,\n)\n\nfrom pytamaro.de import kombiniere\n\nIm folgenden soll es darum gehen diese Scheneeflocke\n\naus Elementen, wie dem folgenden\n\nzusammenzubauen.\nDabei ist die Grundkomponente offensichtlich eine kurze Gerade.\n\ndef draw_line(length: float) -&gt; Graphic:\n    # TODO: implementieren Sie das zeichnen einer geraden\n    pass\n\nshow_graphic(draw_line(50))\n\nAus dieser kurzen Geraden, kann ein einzelner Zacken zusammengebaut werden.\n\ndef compose_element(element: Graphic) -&gt; Graphic:\n    #TODO: zeichnen Sie aus der Grafik der vorangegangenen\n    # Funktion einen einzelnen Zacken\n    pass\n\nbasiselement = compose_element(testline)\nshow_graphic(basiselement)\n\nAus diesem einzelnen Zacken ist als nächstes ein fein gezahnte Element zu bauen. Der Funktion soll als Argument die Rekutsionstiefe übergeben werden. Die vorher programmierten Funktionen können als Hilfsfunktionen aufgerufen werden.\n\ndef draw_zahnung(n: int, m = 1) -&gt; Graphic:\n    # TODO: implementieren Sie eine rekursive Funktion\n    # zum zeichnen eines gezahnten Elementes\n    pass        \n\nDie so gezeichnete gezahnte Linie bildet die Basis einer Schneeflocke. Implementieren Sie eine Funktion zum zeichnen einer Schneeflocke. Der Funktion soll die Rekursionstiefe als Argument übergeben werden können.\n\ndef create_snow_flake(n: int) -&gt; Graphic:\n    # TODO: kombinieren Sie die bisherigen Element zu einer Schneeflocke\n    pass\n\nHier finden sie die Musterlösung der Übung Schneeflocke."
  },
  {
    "objectID": "files/lektionen_hs24/241127/selection_sort.html",
    "href": "files/lektionen_hs24/241127/selection_sort.html",
    "title": "Algorithmen",
    "section": "",
    "text": "Der Begriff Algorithmus ist aktuell omnipräsent. Oft hat der Begriff allerdings einen negativen Unterton weil er mit etwas intransparenten und unkontrollierbaren in Verbindung gebracht wird. Aber was ist eigentlich ein Algorithmus?\nDie Wikipedia definiert den Begriff folgendermassen:\nDonald E. Knuth beschreibt im ersten Band seines fundamentalen, sieben Bände umfassenden, Werkes “The Art of Computer Programming” die Herkunft des Begriffes. Es handelt sich um die mit der Zeit entstellte Form des letzten Teils des Namens von Abu ’Abd Allah Muhammad ibn Musa al-Khwarizmi1, eines persischen Mathematikers aus dem 9. Jahrhundert.\nSalopp umformuliert ist ein Algorithmus ein Rezept zum Lösen konkreter Probleme."
  },
  {
    "objectID": "files/lektionen_hs24/241127/selection_sort.html#algorithmen-in-der-informatik",
    "href": "files/lektionen_hs24/241127/selection_sort.html#algorithmen-in-der-informatik",
    "title": "Algorithmen",
    "section": "Algorithmen in der Informatik",
    "text": "Algorithmen in der Informatik\nWie Alogrithmen in der Informatik verwendet werden, soll am Beispiel der Berechnung des grössten gemeinsamen Teilers mit dem euklidischen Algorithmus gezeigt werden. Der griechische Mathematiker Euklid, nach dem der Algorithmus benannt ist, hat das Verfahren im 3. Jahrhundert v. Chr. beschrieben.\nAlgorithmus E (Euklidischer Algorithmus). Gegeben seien zwei positive natürliche Zahlen \\(m\\) und \\(n\\). Gesucht ist deren grösster gemeinsamer Teiler.\nE1. Rest berechnen. Teile \\(m\\) durch \\(n\\). Der Rest sei \\(r\\). (Es gilt \\(0 \\leq r &lt; n\\).)\nE2. Ist der Rest null? Wenn \\(r = 0\\) endet der Algorithmus und \\(n\\) ist die Lösung.\nE3. Reduzieren. Setze \\(m \\leftarrow n, n \\leftarrow r\\) und gehe zurück zu Schritt E1.2\nDer Algorithmus E kann in das folgende Flussdiagramm übersetzt werden.\n\n\n\nFlussdiagramm Algorithmus E\n\n\nDie graphische Darstellung von Algorithmus E als Flussdiagramm hilft, eine entsprechende Funktion in Python zu implementieren.\ndef euclid(m : int, n : int) -&gt; int:\n    r = m % n\n    while r &gt; 0:\n        m = n\n        n = r\n        r = m % n\n    return n\n\nExkurs Sichtbarkeit von Variablen\nDie Namen von Variablen in Python sind nicht im ganzen Programm sichtbar. Entscheidend ist, wo die Variable definiert werden. Variablen, die innerhalb einer Funktion definiert werden, sind nur innerhalb dieser Funktion sichtbar. Variablen, welche in einem File (Modul) definiert werden, sind grundsätzlich nur in diesem Modul sichtbar.\nSo ist es möglich, den gleichen Namen für verschiedene Variablen zu vergeben."
  },
  {
    "objectID": "files/lektionen_hs24/241127/selection_sort.html#aufgabe",
    "href": "files/lektionen_hs24/241127/selection_sort.html#aufgabe",
    "title": "Algorithmen",
    "section": "Aufgabe",
    "text": "Aufgabe\nBerechnen Sie von Hand nach dem Euklidischen Algorithmus den grössten gemeinsamen Teiler für die Zahlen 544 und 119. Erstellen Sie eine Tabelle in welcher Schlaufe für Schlaufe die Werte für die Variablen \\(m\\) und \\(n\\) eingetragen sind."
  },
  {
    "objectID": "files/lektionen_hs24/241127/selection_sort.html#musterlösung",
    "href": "files/lektionen_hs24/241127/selection_sort.html#musterlösung",
    "title": "Algorithmen",
    "section": "Musterlösung",
    "text": "Musterlösung\nDer grösste gemeinsame Teiler für 544 und 119 ist 17.\n\n\n\nDurchlauf\nm\nn\n\n\n\n\n0\n544\n119\n\n\n1\n119\n68\n\n\n2\n68\n51\n\n\n3\n51\n17\n\n\n\nEine weiteres Beispiel findet sich in diesem Jupyter Notebook.\nDie Musterlösung findet sich hier.\nHier findet sich die Musterlösung der in der Lektion besprochenen vorgehensweise."
  },
  {
    "objectID": "files/lektionen_hs24/241127/selection_sort.html#footnotes",
    "href": "files/lektionen_hs24/241127/selection_sort.html#footnotes",
    "title": "Algorithmen",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nKnuth, Donald Ervin; The Art of Computer Programming (Fundamental Algorithms); 3rd ed.; Bd. I.; Reading, Mass: Addison-Wesley, 1997; Seite. 1.↩︎\nKnuth, aaO., Seite 2 f.↩︎"
  },
  {
    "objectID": "files/lektionen_hs24/241113/lists.html",
    "href": "files/lektionen_hs24/241113/lists.html",
    "title": "Datenstrukturen in Python: Listen",
    "section": "",
    "text": "Eine Datenstruktur kann allgemein als Bündelung von Daten und Funktionalitäten verstanden werden. Wie das funktioniert, soll am Beispiel von Python-Listen gezeigt werden.\nPython-Listen können dazu verwendet werden, einer Variabel mehrere Werte zuzuweisen. Die Werte behalten dabei grundsätzlich ihre ursprüngliche Reihenfolge bei. Listen werden in der Regel nach der Art Ihrer Elemente benannt. Wenn eine Python-Liste von Namen erstellt wird, wird sie beispielsweise der Variablen names zugewiesen. Die Variable wird als Kennzeichen dafür, dass sie auf eine Python-Liste verweist, in den Plural gesetzt."
  },
  {
    "objectID": "files/lektionen_hs24/241113/lists.html#python-listen-erstellen",
    "href": "files/lektionen_hs24/241113/lists.html#python-listen-erstellen",
    "title": "Datenstrukturen in Python: Listen",
    "section": "Python-Listen erstellen",
    "text": "Python-Listen erstellen\nAm einfachsten werden Python-Listen durch die Eingabe von konkreten Werten des betrachteten Datentypen erstellt. Dazu werden die Werte der Python-Liste durch Kommas getrennt in eckigen Klammern geschrieben:\nnumbers = [1, 8, 3]\nGrafisch kann man sich diese Python-Liste folgendermassen vorstellen:\n\nAlternativ kann eine Liste mit Gemüsen erstellt werden:\nvegetables = ['Spinat', 'Sellerie', 'Blumenkohl']"
  },
  {
    "objectID": "files/lektionen_hs24/241113/lists.html#auf-elemente-einer-python-liste-zugreifen",
    "href": "files/lektionen_hs24/241113/lists.html#auf-elemente-einer-python-liste-zugreifen",
    "title": "Datenstrukturen in Python: Listen",
    "section": "Auf Elemente einer Python-Liste zugreifen",
    "text": "Auf Elemente einer Python-Liste zugreifen\nDie Elemente einer Python-Liste sind geordnet und indexiert. Geordnet heisst, dass die Python-Liste die Reihenfolge der Elemente so behält, wie sie erstellt wird - zumindest solange die Python-Liste nicht verändert wird. Indexiert heisst, dass jedes Element einer Python-Liste eine Nummer erhält. Allerdings beginnt man mit Null zu zählen. Das bedeutet, dass der Sellerie in der Python-Liste vegetables den Index 1 hat.\nUm das zweite Element der Python-Liste auszugeben, muss Python nach dem Element mit dem Index 1 der entsprechenden Python-Liste gefragt werden:\nprint(vegetables[1])\ngibt\nSellerie\n\nPython-Listen haben noch einen zweiten Index. Dieser beginnt beim letzten Element mit -1 und zählt mit einem negativen Vorzeichen bis zum ersten Element hoch. Auf das Element Blumenkohl kann also auch mit vegetables[-1] zugegriffen werden."
  },
  {
    "objectID": "files/lektionen_hs24/241113/lists.html#über-python-listen-iterieren",
    "href": "files/lektionen_hs24/241113/lists.html#über-python-listen-iterieren",
    "title": "Datenstrukturen in Python: Listen",
    "section": "Über Python-Listen iterieren",
    "text": "Über Python-Listen iterieren\nUm der Reihe nach auf die einzelnen Elemente einer Liste zuzugreifen, kann mit einer for Schlaufe über die Liste iteriert (darüber gelaufen) werden. Das folgende Listing zeigt, wie über die Gemüseliste iteriert werden kann.\nfor vegetable in vegetables:\n    print(vegetable)\nFür dieses Vorgehen hat sich eingebürgert, dass man die laufende Variabel (vgetable) im Singular der Variabel der Liste (vegetables) benennt.\nInnerhalb der Schlaufe nimmt die laufende Variabel der Reihe nach jeden Wert der Python Liste an und verarbeitet ihn gemäss den Programmanweisungen im Körper der Schlaufe (hier print(vegetable))."
  },
  {
    "objectID": "files/lektionen_hs24/241113/lists.html#python-listen-mit-list-comprehensions-erstellen",
    "href": "files/lektionen_hs24/241113/lists.html#python-listen-mit-list-comprehensions-erstellen",
    "title": "Datenstrukturen in Python: Listen",
    "section": "Python-Listen mit list comprehensions erstellen",
    "text": "Python-Listen mit list comprehensions erstellen\nPython-Listen können auch mit einer sogenannten list comprehension erstellt werden. Das folgende Listing zeigt ein einfaches Beispiel einer list comrprehension.\nexample_numbers = [i for i in range(1,21)]\nDie Datenstruktur enthält also 20 Variablen mit den Werten example_numbers[0] = 1, example_numbers[1] = 2, …, example_numbers[19] = 20.\nGrafisch dargestellt sieht das wie unten dargestellt aus.\n\nDies ermöglicht es uns, alle Variablen einzeln anzusprechen.\nEine list comprehension funktioniert ähnlich, wie die Beschreibung einer Menge in der Mathematik (\\[\n\\{x \\in \\mathbb{N} \\mid \\color{red} 1 \\geq x &gt; 21\\color{black}\\}\n\\]).\nDer Teil\nfor i in range(1,21)\nentspricht dabei der Bedingung (oben rot dargestellt) in der Beschreibung einer Menge. 1 ist der Startwert bei dem die Variabel i zu zählen beginnt. Man nennt eine Variable wie i eine Laufvariable. 21 ist die obere Grenze. Die Grenze selber wird nicht mitgezählt.\nEin etwas komplexeres Beispiel resultiert, wenn die list comrehension mit einer Bedingung verknüpft wird.\neven_example_numbers = [i for i in range(1,21) if i % 2 == 0]\nIn die Python-Liste even_example_numbers werden nur jene Werte für i aufgenommen, welche die Bedingung i % 2 == 0 erfüllen. Das sind in diesem Fall die geraden Zahlen von 1 bis (und mit) 20. Dies entspricht der Mengenbeschreibung \\[\n\\{x \\in \\mathbb{N} \\mid 1 \\geq x &gt; 21, x \\bmod 2 = 0\\}\n\\].\nAnstelle der Funktion range() kann in einer list comprehension auch eine bereits bestehende Python-Liste verwendet werden. So kann mit einer list comprehension eine neue Liste erstellt werden, die aus Elementen einer Liste besteht, welche bestimmte Bedingungen erfüllen. Das folgende Listing soll dies verdeutlichen.\nhundert = [i for i in range(1,101)]\nhundert_mit_bedingungen = [x for x in hundert if x % 7 == 0 and x &gt; 50]\nDie zweite list comprehension erstellt hier eine Liste mit Zahlen, die durch 7 Teilbar und grösser als 50 sind."
  },
  {
    "objectID": "files/lektionen_hs24/241113/lists.html#übungen",
    "href": "files/lektionen_hs24/241113/lists.html#übungen",
    "title": "Datenstrukturen in Python: Listen",
    "section": "Übungen",
    "text": "Übungen\nDie obigen Erklärungen können auf dem  hier verlinkten Jupyter Notebook eingeübt werden.  Hier finden Sie eine Musterlösung zum Arbeitsblatt."
  },
  {
    "objectID": "files/lektionen_hs24/240925/main.html",
    "href": "files/lektionen_hs24/240925/main.html",
    "title": "Bedingungen in Python",
    "section": "",
    "text": "Es gibt Situationen, in denen soll einzelne Anweisungen eines Programmes nur dann ausgeführt werden, wenn eine bestimmte Bedingung zutrifft. Die allgemeine Struktur einer solchen wenn-dann-sonst-Konstruktion sieht folgendermassen aus:\nWENN Bedingung DANN\n    Anweisungen, die ausgeführt werden, wenn die Bedingung wahr ist\nSONST\n    Anweisungen, die ausgeführt werden, wenn die Bedingung falsch ist\nENDE WENN\nIn Python wird das als\nif x == True\n    ...\nelse:\n    ...\ndargestellt. Dabei können nach dem if beliebige Bedingungen formuliert werden. Die dazu erforderlichen Vergleichsoperatoren sind\n\n\n\nOperator\nBedeutung\n\n\n\n\n==\nist gleich\n\n\n!=\nnicht gleich\n\n\n&lt;=\nkleiner gleich\n\n\n&gt;=\ngrösser gleich\n\n\n\nMehrere Bedingungen können dabei mit und bzw. oder verknüpft werden. Die Verknüpfung der Bedingungen erfolgen nach den Regeln der formalen Logik."
  },
  {
    "objectID": "files/lektionen_hs24/240925/main.html#bedinungen",
    "href": "files/lektionen_hs24/240925/main.html#bedinungen",
    "title": "Bedingungen in Python",
    "section": "",
    "text": "Es gibt Situationen, in denen soll einzelne Anweisungen eines Programmes nur dann ausgeführt werden, wenn eine bestimmte Bedingung zutrifft. Die allgemeine Struktur einer solchen wenn-dann-sonst-Konstruktion sieht folgendermassen aus:\nWENN Bedingung DANN\n    Anweisungen, die ausgeführt werden, wenn die Bedingung wahr ist\nSONST\n    Anweisungen, die ausgeführt werden, wenn die Bedingung falsch ist\nENDE WENN\nIn Python wird das als\nif x == True\n    ...\nelse:\n    ...\ndargestellt. Dabei können nach dem if beliebige Bedingungen formuliert werden. Die dazu erforderlichen Vergleichsoperatoren sind\n\n\n\nOperator\nBedeutung\n\n\n\n\n==\nist gleich\n\n\n!=\nnicht gleich\n\n\n&lt;=\nkleiner gleich\n\n\n&gt;=\ngrösser gleich\n\n\n\nMehrere Bedingungen können dabei mit und bzw. oder verknüpft werden. Die Verknüpfung der Bedingungen erfolgen nach den Regeln der formalen Logik."
  },
  {
    "objectID": "files/lektionen_hs24/240925/main.html#aussagenlogik-verknüpfung-von-bedingungen",
    "href": "files/lektionen_hs24/240925/main.html#aussagenlogik-verknüpfung-von-bedingungen",
    "title": "Bedingungen in Python",
    "section": "Aussagenlogik (Verknüpfung von Bedingungen)",
    "text": "Aussagenlogik (Verknüpfung von Bedingungen)\nComputer verarbeiten Daten. Daten werden im Computer als Nullen und Einsen oder als “Strom” und “kein Strom” dargestellt. Mit diesen zwei Zuständen lässt sich alles darstellen. Weil alles mit zwei Zuständen dargestellt werden kann ist diese Form der Darstellung digital.\nIm folgenden sollen die logischen Operationen\n\nlogisches Nicht (not)\nlogisches Und (and)\nlogisches Oder (or)\nlogisches Exklusiv-Oder (xor)\n\nbetrachtet werden.\n\nDie Negation\nDie logische Negation wird als nicht-Operation bezeichnet.\nWenn es nur zwei Werte - 0 und 1 - gibt, dann ist\n\nder Wert, der nicht 0 ist, 1 und\nder Wert, der nicht 1 ist, 0.\n\nNicht wird mit dem Symbol ¬ oder \\(\\ \\bar{ }\\ \\) (Strich über dem verneinten Zeichen) dargestellt.\nMan kann damit schreiben\n\\(\\lnot 1 = 0\\)\noder\n\\(\\bar{1} = 0\\)\nDie Verneinung kann in einer sogenannten Wahrheitstabelle dargestellt werden.\n\n\n\n\\(x\\)\n\\(\\bar{x}\\)\n\n\n\n\n0\n1\n\n\n1\n0\n\n\n\nMit Wahrheitstabellen lassen sich auch andere logische Operationen definieren.\n\n\nLogisches Und (and)\nDas logische Und (and) wird mit dem Symbol \\(\\land\\) dargestellt.\nDie Wahrheitstabelle dafür sieht folgendermassen aus:\n\n\n\n\\(x\\)\n\\(y\\)\n\\(x \\land y\\)\n\n\n\n\n0\n0\n0\n\n\n0\n1\n0\n\n\n1\n0\n0\n\n\n1\n1\n1\n\n\n\n\n\nLogisches Oder (or)\nDas logische Oder (or) wird mit dem Symbol \\(\\lor\\) dargestellt.\nDie Wahrheitstabelle für das logische Oder sieht folgendermassen aus:\n\n\n\n\\(x\\)\n\\(y\\)\n\\(x \\lor y\\)\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n1\n\n\n\n\n\nLogisches exklusiv-Oder (xor)\nDas logische exklusiv-Oder (xor) wird mit dem Symbol \\(\\dot\\lor\\) dargestellt.\nDie Wahrheitstabelle für das logische exklusiv-Oder sieht folgendermassen aus:\n\n\n\n\\(x\\)\n\\(y\\)\n\\(x \\dot\\lor y\\)\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\n\nRangfolge logischer Operatoren\nAnalog zu den arithmetischen Operationen haben auch die logischen Operatoren eine Rangfolge. Am stärksten bindet dabei not (\\(\\lnot x\\) oder \\(\\bar{x}\\)) gefolgt von and (\\(x \\land y\\)) und or (\\(x \\lor y\\))."
  },
  {
    "objectID": "files/lektionen_hs24/240925/main.html#arbeitsblatt",
    "href": "files/lektionen_hs24/240925/main.html#arbeitsblatt",
    "title": "Bedingungen in Python",
    "section": "Arbeitsblatt",
    "text": "Arbeitsblatt\nHier finden Sie ein Arbeitsblatt für die Arbeit mit Bedingungen in Python."
  },
  {
    "objectID": "files/lektionen_hs24/240911/Variablen.html",
    "href": "files/lektionen_hs24/240911/Variablen.html",
    "title": "Variablen und Datentypen in Python",
    "section": "",
    "text": "Python verfügt über eingebaute mathematische Fähigkeiten. Es kann die Grundrechenarten und kennt die Hierarchie der Operationen. Sie können das überprüfen, in dem Sie in der folgenden Zelle die Rechnung \\[2+3\\cdot4\\] ausführen.\n\n# hier können Sie die Rechnung ausführen\n\nDie folgende Tabelle gibt einen Überblick über die direkt in Python verfügbaren mathematischen Funktionen:\n\n\n\nBeschreibung\nBefehl\nBeispiel\n\n\n\n\nAddition\n+\n2 + 3\n\n\nSubtraktion\n-\n3 - 2\n\n\nMultiplikation\n*\n3 * 2\n\n\nDivision\n/\n3 / 2\n\n\nPotenzen\n**\n3 ** 2\n\n\nWurzeln\n**(1/n)\n16 ** (1/2)\n\n\nGanzzahlige Division\n//\n7 // 2\n\n\nModulo\n%\n7 % 2"
  },
  {
    "objectID": "files/lektionen_hs24/240911/Variablen.html#python-als-rechner",
    "href": "files/lektionen_hs24/240911/Variablen.html#python-als-rechner",
    "title": "Variablen und Datentypen in Python",
    "section": "",
    "text": "Python verfügt über eingebaute mathematische Fähigkeiten. Es kann die Grundrechenarten und kennt die Hierarchie der Operationen. Sie können das überprüfen, in dem Sie in der folgenden Zelle die Rechnung \\[2+3\\cdot4\\] ausführen.\n\n# hier können Sie die Rechnung ausführen\n\nDie folgende Tabelle gibt einen Überblick über die direkt in Python verfügbaren mathematischen Funktionen:\n\n\n\nBeschreibung\nBefehl\nBeispiel\n\n\n\n\nAddition\n+\n2 + 3\n\n\nSubtraktion\n-\n3 - 2\n\n\nMultiplikation\n*\n3 * 2\n\n\nDivision\n/\n3 / 2\n\n\nPotenzen\n**\n3 ** 2\n\n\nWurzeln\n**(1/n)\n16 ** (1/2)\n\n\nGanzzahlige Division\n//\n7 // 2\n\n\nModulo\n%\n7 % 2"
  },
  {
    "objectID": "files/lektionen_hs24/240911/Variablen.html#variablen",
    "href": "files/lektionen_hs24/240911/Variablen.html#variablen",
    "title": "Variablen und Datentypen in Python",
    "section": "Variablen",
    "text": "Variablen\nIn Python sind Variablen symbolische Namen für gespeicherte Daten. Variablen verweisen dabei auf den Speicherbereich im Computer, in dem die entsprechenden Daten physikalisch abgelegt sind. Aus diesem Grund werden Variablen gelegentlich auch als Zeiger bezeichnet. Was genau für Daten in diesem Speicherbereich abgelegt werden, spielt keine Rolle und kann während der Ausführung eines Programmes auch ändern.\nVariablen werden Werte mit dem Gleichheitszeichen zugewiesen. Um der Variable \\(x\\) den Wert \\(2\\) zuzuweisen, ist die Eingabe x = 2 erfoderlich. Die Variable steht links vom Gleichheitszeichen, der zuzuweisende Wert rechts davon.\nÜberprüfen Sie dies, indem Sie in der folgenden Zelle der Variabel \\(y\\) den Wert \\(3\\) und der Variabel \\(z\\) den Wert \\(4\\) zuweisen. Anschliessend multipliziern Sie die beiden Variablen miteinander.\n\n# hier die Aufgabe einfüllen\n\nWenn Variablen neue Werte zugewiesen werden, wird die Referenz auf den Speicherbereich mit dem alten Wert gelöscht. Die Daten, welche ohne Verweis durch eine Variable im Speicher liegen, werden vom in Python eingebauten Garbage Collector im Hintergrund gelöscht und der so freigewordene Speicherplatz kann wieder verwendet werden.\nSie können überprüfen, dass Variablen neue Werte zugewiesen werden können, indem Sie in der untenstehenden Zelle die Variabeln \\(y\\) und \\(z\\) addieren. Sie erhalten dann das Resultat \\(7\\). Das heisst, den Variablen \\(y\\) und \\(z\\) sind immer noch die Werte \\(3\\) und \\(4\\) zugewiesen.\n\n# addieren Sie hier y und z\n\nWenn Sie in der folgenden Zelle der Variabel \\(y\\) den Wert \\(5\\) zuweisen und anschliessend \\(y\\) und \\(z\\) addieren erhalten Sie als neues Resultat \\(9\\).\n\n# weisen Sie hier y den neuen Wert zu\n\nVariablen können auch Resultate von Berechnungen zugewiesen werden. Ausserdem können Variablen ganze Wörter als Namen haben. Dies ist gegenüber einzelnen Buchstaben vorzuziehen, weil dann aussagekräftige Namen gewählt werden können. Grundsätzich sind die Namen von Variabeln frei wählbar. Es gibt allerdings eine Reihe von reservierten Begriffen, welche in der Programmiersprache Python eine eigene Bedeutung haben. Unzulässig sind ausserdem Namen, die mit Ziffern beginnen.\nFür die Darstellung von Namen für Variablen hat sich in Python eingebürgert, Variablen klein zu schreiben und Wörter durch Underlines zu trennen (\\(this\\_is\\_a\\_valid\\_variable\\)). Diese Darstellung nennt sich Snake Case. Zudem werden Variablen meist mit englischen Begriffen bezeichnet.\nWeisen Sie in der nächsten Zelle der Variable result das Resultat der Rechnung \\(y + z\\) zu und geben Sie das Resultat mit print(result) aus. print() ist eine Funktion, die Python zur Verfügung stellt. Was Funktionen sind, wird im nächsten Abschnitt erklärt.\n\n# weisen Sie hier der Variable result das Resultat zu"
  },
  {
    "objectID": "files/lektionen_hs24/240911/Variablen.html#funktionen-in-python",
    "href": "files/lektionen_hs24/240911/Variablen.html#funktionen-in-python",
    "title": "Variablen und Datentypen in Python",
    "section": "Funktionen in Python",
    "text": "Funktionen in Python\nPython verfügt über viele bereits vordefinierte Funktionen. Die oben verwendete Funktion print() ist ein Beispiel dafür. Um zu demonstrieren, wie Funktionen in Python definiert werden, zeige ich Ihnen als Beispiel eine Funktion, mit der zwei Zahlen addiert werden.\n\ndef get_sum(x, y):\n    return x + y\n\nresult = get_sum(3,4)\nprint(result)\n\ndef ist das Schlüsselwort für die Definition einer Funktion. get_sum ist der von mir gewählte Name dieser Funktion. Für die Wahl des Namens einer Funktion gelten die gleichen Regeln, wie für Variablen. In den Klammern stehen die sogenannten Parameter, welche der Funktion übergeben werden, damit sie etwas damit macht. Mit dem Doppelpunkt wird die Signatur der Funktion abgeschlossen. Die Signatur zeigt idealerweise, was eine Funktion womit macht. Sie gibt aber keine Auskunft darüber, wie sie das macht.\nPython gruppiert Befehle, die zusammengehören, durch die gleiche Tiefe der Einrückung. Eine Einrückung hat üblicherweise die Tiefe von vier Leerzeichen. Im Beispiel oben gibt es nur eine eingerückte Zeile, weil die Funktion nur aus einem Befehl besteht. Mit return gibt die Funktion das Resultat zurück.\nIm Beispiel wird das Resultat der Berechnung, welche die Funktion ausführt der Variable result zugewiesen. Der Wert der Variable result wird mit print(result) ausgegeben.\nDefinieren Sie in der folgenden Zelle eine Funktion, mit der zwei Zahlen multipliziert werden.\n\n# hier kommt Ihre Funktion hin"
  },
  {
    "objectID": "files/lektionen_hs24/240911/Variablen.html#datentypen",
    "href": "files/lektionen_hs24/240911/Variablen.html#datentypen",
    "title": "Variablen und Datentypen in Python",
    "section": "Datentypen",
    "text": "Datentypen\nAls nächstes geht es um die Frage, auf welche Inhalte eine Variable zeigen kann.\nIm Grundsatz kann eine Variable auf beliebige Inhalte verweisen.\nAm einfachsten ist die Verwendung der grundlegenden Datenypen (basic data types), welche Python zur Verfügung stellt. Dies sind (mit ihren englischen Bezeichnungen):\n\nInteger (Ganzzahl)\nFloating-Point Number (Gleitkommazahl)\nComplex Number (komplexe Zahl)\nString (Zeichenkette)\nBoolean Type (Wahrheitswert)\n\nDarüber hinaus ist es möglich, eigene Datentypen zu programmieren. Hier aber zuerst eine Beschreibung der grundlegenden Datentypen von Python.\n\nInteger\nDie Bezeichnung für Integer in Python ist ein kurzes int.\nAnders als in anderen Progammiersprachen gibt es in Python theoretisch keine Beschränkung, wie gross ein Integer sein kann. Die einzige Grenze ist der Speicherplatz des konkreten Systems.\nWenn einer Variable ein grosser Integer zugewiesen wird, kann dieser zur besseren Lesbarkeit auch mit einem Underline als Tausendertrennzeichen geschrieben werden (100_000).\nUm das Auszuprobieren, weisen Sie in der folgenden Zelle der Variable \\(a\\) den Wert von einer Million und der Variable \\(b\\) den Wert von einer Milliarde zu. Anschliessend addieren Sie \\(a\\) und \\(b\\) und weisen das Resultat der Variable \\(big\\_sum\\) zu. Zum Schluss geben Sie den Wert von \\(big\\_sum\\) mit der Funktion print() aus.\n\n# hier können Sie Ihre Berechnung vornehmen\n\nEingegebene Zahlen werden automatisch als Dezimalzahlen interpretiert.\nIntegers können jedoch auch als Binär-, Oktal- oder Hexadezimalzahlen eingegeben werden. Die Eingabe erfordert dann allerdings ein Präfix, welches das Zahlensysten identifiziert. Die folgende Tabelle stellt die möglichen Präfixe zusammen.\n\n\n\nPräfix\nBedeutung\nBasis\n\n\n\n\n0b (Null + Kleinbuchstabe b)\nBinärzahl\n2\n\n\n0B (Null + Grossbuchstabe B)\n\n2\n\n\n0o (Null + Kleinbuchstabe o)\nOktalzahl\n8\n\n\n0O (Null + Grossbuchstabe O)\n\n8\n\n\n0x (Null + Kleinbuchstabe x)\nHexadezimalzahl\n16\n\n\n0X (Null + Grossbuchstabe X)\n\n16\n\n\n\nIn der folgende Zelle finden Sie ein entsprechendes Beispiel.\n\nb = 0b101010\no = 0o52\nx = 0x2a\n\nprint(b, o, x)\n\n\n\nGleitkommazahl\nDie Bezeichnung für Gleitkommazahlen in Python ist float. Python interpretiert Zahlen mit einem Dezimalpunkt als Gleitkommazahlen. Optional können Zahlen mit e oder E in “wissenschaftlicher” Schreibweise eigegeben werden (1000 = 1e3 bzw. 1e-3 = 0.001).\nWeisen Sie in der folgenden Zelle den Variablen million und billionth die passenden Werte in wissenschaftlicher Schreibweise zu.\n\n# hier die Werte den beiden Variablen zuweisen\n\n\n\nKomplexe Zahlen\nPython kann auch mit komplexen Zahlen umgehen. Der Abschnitt zu diesem Thema kann wieder aufgegriffen werden, wenn Sie in Mathe die komplexen Zahlen besprochen haben.\n\n\nString\nZeichenketten werden von Python als str bezeichnet.\nZeichenketten sind beliebige Zeichenfolgen. Damit Python Zeichenketten als solche erkennt, müssen sie durch die Verwendung von einfachen oder doppelten Anführungs- und Schlusszeichen als solche gekennzeichnet werden.\n\"Ich bin eine Zeichenkette.\" oder 'Ich bin auch eine Zeichenkette.'\nWenn man in der Zeichenkette Anführungszeichen braucht, müssen die eingrenzenden Anfürhungszeichen von der “anderen Sorte” sein (\"It's cool learning Python!\" oder 'Der Lehrer sagt: \"Es ist cool Python zu lernen.\"'). Eine andere Möglichkeit reservierte Zeichen zu verwenden ist der Gebrauch eines “escape”-Zeichens. In Python ist das der “backslash”. Die beiden Beispielsätze von vorher hätten entsprechend auch folgendermassen geschrieben werden können:\n'It\\'s cool learning Python!' bzw. \"Der Lehrer sagt: \\\"Es ist cool Python zu lernen.\\\"\"\nDie Länge von Zeichenketten wird lediglich durch die Speicherkapazität des Systems begrenzt. Insbesondere kann eine Zeichenkette auch leer sein ('').\nZeichenketten können, wie alle Datentypen, Variablen zugewiesen werden.\n\nstandard_greeting = \"Hello World\"\nprint(standard_greeting)\n\n\n\nBoolean Type\nWahrheitswerte werden in Python als bool bezeichnet. Wahrheitswerte können entweder “wahr” oder “falsch” sein.\nWahrheitswerte werden zur Steuerung von Programmflüssen verwendet. Mit einem Wahrheitswert kann zum Beispiel gesteuert werden, wie oft ein Programmteil wiederholt werden soll."
  },
  {
    "objectID": "files/lektionen_hs24/240911/Variablen.html#funktionen-mit-type-hints",
    "href": "files/lektionen_hs24/240911/Variablen.html#funktionen-mit-type-hints",
    "title": "Variablen und Datentypen in Python",
    "section": "Funktionen mit Type-Hints",
    "text": "Funktionen mit Type-Hints\nZum Abschluss komme ich noch einmal auf die Definition von Funktionen zurück. In Python können Variablen - anders als zum Beispiel in Java - beliebige Datentypen zugewiesen werden. Wenn Variablen im Verlauf eines Programms mehrfach verwendet werden, können ihnen auch unterschiedliche Datentypen zugewiesen werden. Dies ist allerdings schlechter Programmierstil.\nAus diesem Grund ist es sinnvoll, bei der Definition einer Funktion zu deklarieren, welche Datentypen die Parameter haben und welcher Datentyp der Rückgabewert hat. Dies soll mit dem Beispiel der Funktion get_quotient verdeutlicht werden.\n\ndef get_quotient(x : int, y : int) -&gt; float:\n    return x / y\n\nHier wird angegeben, dass die Parameter \\(x\\) und \\(y\\) vom Datentyp int sein sollen. Der Datentyp des Rückgabewertes wird hinter -&gt; geschrieben. Im Beispiel ist der Rückgabewert vom Typ float. Das ist so, weil die Funktion zum Beispiel \\(3 / 4 = 3.5\\) rechnet.\nAber Achtung: die Funktion arbeitet auch dann korrekt, wenn ein anderer als der deklarierte Datentyp übergeben wird. Voraussetzung ist lediglich, dass der Datentyp mit den verwendeten Operationen kompatibel ist. Die “Type-Hints” dienen lediglich der besseren Nachvollziehbarkeit, was die Funktion macht."
  },
  {
    "objectID": "files/lektionen_hs24/240828/installationsanleitungen.html",
    "href": "files/lektionen_hs24/240828/installationsanleitungen.html",
    "title": "Erforderliche Systemeinrichtungen",
    "section": "",
    "text": "Im Unterricht im obligatorischen Fach Informatik werden wir Programme in der Programmiersprache Python schreiben. Damit dies möglich ist, müssen Sie an Ihrem Computer ein paar Vorbereitungsarbeiten vornehmen."
  },
  {
    "objectID": "files/lektionen_hs24/240828/installationsanleitungen.html#installation-von-python",
    "href": "files/lektionen_hs24/240828/installationsanleitungen.html#installation-von-python",
    "title": "Erforderliche Systemeinrichtungen",
    "section": "Installation von Python",
    "text": "Installation von Python\nAls erstes müssen Sie die Programmiersprache Python auf Ihrem Computer verfügbar machen. Hier finden Sie eine entsprechende Anleitung."
  },
  {
    "objectID": "files/lektionen_hs24/240828/installationsanleitungen.html#einrichten-einer-virtuellen-arbeitsumgebung",
    "href": "files/lektionen_hs24/240828/installationsanleitungen.html#einrichten-einer-virtuellen-arbeitsumgebung",
    "title": "Erforderliche Systemeinrichtungen",
    "section": "Einrichten einer virtuellen Arbeitsumgebung",
    "text": "Einrichten einer virtuellen Arbeitsumgebung\nEs ist gute Praxis, Python Programme in einer virtuellen Arbeitsumgebung zu schreiben und auszuführen. Eine Beschreibung, wie das geht, finden Sie hier."
  },
  {
    "objectID": "files/lektionen_hs24/240828/installationsanleitungen.html#editor-zum-erstellen-von-python-programmen",
    "href": "files/lektionen_hs24/240828/installationsanleitungen.html#editor-zum-erstellen-von-python-programmen",
    "title": "Erforderliche Systemeinrichtungen",
    "section": "Editor zum erstellen von Python Programmen",
    "text": "Editor zum erstellen von Python Programmen\nGrundsätzlich können Sie Python Programme in einem beliebigen Texteditor erstellen. Um Ihnen die Arbeit etwas zu erleichtern verwenden wir im Unterricht Visual Studio Code."
  },
  {
    "objectID": "files/lektionen_hs24/240828/installationsanleitungen.html#jupyter-notebooks-zum-erstellen-von-python-programmen",
    "href": "files/lektionen_hs24/240828/installationsanleitungen.html#jupyter-notebooks-zum-erstellen-von-python-programmen",
    "title": "Erforderliche Systemeinrichtungen",
    "section": "Jupyter Notebooks zum erstellen von Python Programmen",
    "text": "Jupyter Notebooks zum erstellen von Python Programmen\nDamit Sie Ihre Pythonprogramme einfach mit den nötigen Notizen versehen können und allenfalls auch ausdrucken, verwenden wir im Unterricht sogenannte Jupyter Notebooks. Wie Sie das für VS Code vorbereiten, wird hier erklärt."
  },
  {
    "objectID": "files/lektionen_hs24/240828/installationsanleitungen.html#arbeitsumgebung-in-der-lokalen-ordnerstruktur",
    "href": "files/lektionen_hs24/240828/installationsanleitungen.html#arbeitsumgebung-in-der-lokalen-ordnerstruktur",
    "title": "Erforderliche Systemeinrichtungen",
    "section": "Arbeitsumgebung in der lokalen Ordnerstruktur",
    "text": "Arbeitsumgebung in der lokalen Ordnerstruktur\nIch gehe davon aus, dass Sie die Dateien für die Schule grundsätzlich folgendermassen organisiert haben:\n+---Schule\n    +---BG\n    +---Chemie\n    +---Deutsch\n    +---Englisch\n    +---Franzoesisch\n    +---Geographie\n    +---Geschichte\n    +---Informatik\n    ¦   +---Einfuehrung\n    +---Klassenstunde\n    +---Mathematik\n    +---Musik\n    +---PPP\nFür das erstellen der verlangten Python Virtual Environment wechseln Sie jeweils in den Ordner Schule&gt;Informatik&gt;Einfuehrung."
  },
  {
    "objectID": "files/lektionen_fs25/250521/lernziele.html",
    "href": "files/lektionen_fs25/250521/lernziele.html",
    "title": "Lernziele für die Prüfung vom 21. Mai 2025",
    "section": "",
    "text": "Ich erwarte, dass Sie in der Lage sind\n\ndie grundsätzlichen Unterschiede zwischen Python und SQL zu erklären;\ndie Aufgaben einer Datenbank aufzuzählen;\ndie Elemente einer grundlegenden SQL Abfrage aufzuzählen sowie\neine SQL Abfrage in umgangssprachliches Deutsch zu übersetzen.\n\nFür Fragen stehe ich Ihnen im Kanal Allgemein zur Verfügung."
  },
  {
    "objectID": "files/lektionen_fs25/250416/datenbank.html",
    "href": "files/lektionen_fs25/250416/datenbank.html",
    "title": "Einführung in Datenbanken",
    "section": "",
    "text": "Die Einführung in Datenbanken basiert auf dem Einführungskapitel aus dem Buch Abraham Silberschatz, Henry F. Korth und S. Sudarshan; Database system concepts; Seventh edition; New York 2020."
  },
  {
    "objectID": "files/lektionen_fs25/250416/datenbank.html#einführung",
    "href": "files/lektionen_fs25/250416/datenbank.html#einführung",
    "title": "Einführung in Datenbanken",
    "section": "Einführung",
    "text": "Einführung\nDie bisher besprochenen Datenstrukturen Dictionary, Stack, Queue, und Binary Search Tree dienen der Bearbeitung von Daten im Arbeitsspeicher. Sie sind daher auf einen beschränkten Umfang von Datensätzen ausgelegt. Ausserdem dienen sie nicht der permanenten Ablage von Daten.\nIm Gegensatz dazu dienen Datenbanken der dauerhaften Ablage grosser Datensätze. Darüber hinaus sollen sie die effiziente Verfügbarkeit und die Integrität der Daten sicherstellen."
  },
  {
    "objectID": "files/lektionen_fs25/250416/datenbank.html#charakteristika-von-datenbanken",
    "href": "files/lektionen_fs25/250416/datenbank.html#charakteristika-von-datenbanken",
    "title": "Einführung in Datenbanken",
    "section": "Charakteristika von Datenbanken",
    "text": "Charakteristika von Datenbanken\nEin wichtiges Merkmal von Datenbanken ist es, dass die gespeicherten Daten nur einmal abgelegt werden. Damit kann verhindert werden, dass mehrfach abgespeicherte Daten (redundante Daten) lediglich an einer Stelle modifiziert werden und damit Widersprüche entstehen. Der Entwurf von Datenbanken muss dem Rechnung tragen. Ein Hilfsmittel für den Entwurf von Datenbanken ist das ER-Diagramm (Entity-Relationship-Diagramm). Das ER-Diagramm ist eine grafische Darstellung der Datenbankstruktur. Es zeigt die Entitäten (durch die Datenbank modellierte Dinge der realen Welt), die in der Datenbank gespeichert werden, mit ihren Attributen (Eigenschaften der modellierten Dinge) sowie die Beziehungen (Relationship) zwischen den Entitäten.\nUm einen Eintrag in der Datenbank eindeutig identifizieren zu können, wird jedem Eintrag ein Primärschlüssel zugeordnet. Der Primärschlüssel ist ein Attribut oder eine Kombination von Attributen, die den Eintrag eindeutig identifiziert.\nIn den Beziehungen werden die Primärschlüssel der Entitäten als Fremdschlüssel verwendet. Ein Fremdschlüssel ist ein Attribut oder eine Kombination von Attributen, die auf den Primärschlüssel einer anderen Entität verweisen. So kann eine Beziehung zwischen zwei Entitäten hergestellt werden.\nDie untenstehende Graphik zeigt eine Skizze eines ER-Diagramms, in welchem die Beziehungen zwischen Schülern, Klassen und Lehrern dargestellt wird. Ausserdem wird gezeigt, welche Attribute als Primär- bzw. Fremdschlüssel verwendet werden.\n\n\n\nER-Diagramm\n\n\nJede Datenbank ist immer eine Vereinfachung der Wirklichkeit und daher immer unvollständig bzw. erweiterbar. Das obige ER-Diagramm kann daher um eine zusätzliche Entität Fach erweitert werden und sieht dann folgendermassen aus:\n\n\n\nER-Diagramm\n\n\nDiese Grafiken können in Datenbanktabellen übersetzt werden. In den Tabellen werden die Primärschlüssel unterstrichen. Die Primärschlüssel sind in der Regel die ersten Spalten der Tabellen. Für das Beispiel werden Tabellen für die Entitäten Klasse, Fach und Lehrer erstellt.\nDie Einfachste Tabelle ist die Tabelle Klasse. Sie enthält lediglich ein Attribut (den Primärschlüssel).\n\n\n\nKlasse\n\n\nEtwas umfangreicher sind die Tabellen Fach und Lehrer. Sie enthalten jeweils drei bzw. vier Attribute.\n\n&lt;img src=\"entity_subject.svg\" alt=\"Tabelle Fach\" style=\"width: 45%;\"&gt;\n&lt;img src=\"entity_teacher.svg\" alt=\"Tabelle Lehrer\" style=\"width: 45%;\"&gt;\n\nIm Folgenden Abschnitt sollen die Daten aus den Tabellen mit Hilfe von SQL Statements abgefragt werden."
  },
  {
    "objectID": "files/lektionen_fs25/250319/base64.html",
    "href": "files/lektionen_fs25/250319/base64.html",
    "title": "Base64-Codierung",
    "section": "",
    "text": "Die Base64-Codierung ist ein Verfahren zur Umwandlung von Binärdaten in eine Zeichenkette, die nur aus lesbaren ASCII-Zeichen besteht. Diese Codierung wird häufig verwendet, um binäre Daten über textbasierte Systeme zu übertragen, die möglicherweise nicht mit Binärdaten umgehen können (z.B. E-Mails)."
  },
  {
    "objectID": "files/lektionen_fs25/250319/base64.html#prinzip-der-base64-codierung",
    "href": "files/lektionen_fs25/250319/base64.html#prinzip-der-base64-codierung",
    "title": "Base64-Codierung",
    "section": "Prinzip der Base64-Codierung",
    "text": "Prinzip der Base64-Codierung\nBase64 wandelt 3 Bytes (24 Bits) Binärdaten in 4 druckbare ASCII-Zeichen um:\n\nDie Binärdaten werden in 6-Bit-Blöcke aufgeteilt (2^6 = 64 mögliche Werte)\nJeder 6-Bit-Block wird in ein druckbares ASCII-Zeichen umgewandelt\nBei unvollständigen Blocks am Ende werden Füllzeichen (=) hinzugefügt"
  },
  {
    "objectID": "files/lektionen_fs25/250319/base64.html#base64-zeichensatz",
    "href": "files/lektionen_fs25/250319/base64.html#base64-zeichensatz",
    "title": "Base64-Codierung",
    "section": "Base64-Zeichensatz",
    "text": "Base64-Zeichensatz\nDer Base64-Zeichensatz besteht aus 64 Zeichen: - Die Großbuchstaben A-Z (26 Zeichen) - Die Kleinbuchstaben a-z (26 Zeichen) - Die Ziffern 0-9 (10 Zeichen) - Zwei zusätzliche Zeichen, meist ‘+’ und ‘/’ (2 Zeichen)\nDiese 64 Zeichen repräsentieren die Werte 0-63 und können mit 6 Bits dargestellt werden."
  },
  {
    "objectID": "files/lektionen_fs25/250319/base64.html#codierungsprozess",
    "href": "files/lektionen_fs25/250319/base64.html#codierungsprozess",
    "title": "Base64-Codierung",
    "section": "Codierungsprozess",
    "text": "Codierungsprozess\n\nDie Binärdaten werden in Gruppen von 3 Bytes (24 Bits) aufgeteilt\nDiese 24 Bits werden in vier 6-Bit-Blöcke umgewandelt\nJeder 6-Bit-Wert wird als Index für den Base64-Zeichensatz verwendet\n\nWenn die Anzahl der zu codierenden Bytes nicht durch 3 teilbar ist: - Bei einem übrig bleibenden Byte: Auffüllen mit vier Nullbits, Codierung ergibt zwei Zeichen und zwei ‘=’-Zeichen - Bei zwei übrig bleibenden Bytes: Auffüllen mit zwei Nullbits, Codierung ergibt drei Zeichen und ein ‘=’-Zeichen"
  },
  {
    "objectID": "files/lektionen_fs25/250319/base64.html#beispiele",
    "href": "files/lektionen_fs25/250319/base64.html#beispiele",
    "title": "Base64-Codierung",
    "section": "Beispiele:",
    "text": "Beispiele:\n\nBeispiel 1: Codierung von “KBW”\n\n\n\nBase64 Beispiel\n\n\n\n\nBeispiel 2: Codierung von “Hallo”\nBetrachten wir das Wort “Hallo”:\n\nASCII-Werte: H=72, a=97, l=108, l=108, o=111\nBinär: 01001000 01100001 01101100 01101100 01101111\nIn 6-Bit-Gruppen aufteilen: 010010 000110 000101 101100 011011 000110 1111\nDa die letzte Gruppe nur 4 Bits hat, wird sie mit zwei Nullen aufgefüllt: 010010 000110 000101 101100 011011 000110 111100\nDie 6-Bit-Werte sind: 18, 6, 5, 44, 27, 6, 60\nDiese werden in Base64-Zeichen umgewandelt: S G F s b G 8 =\n\nDas Ergebnis “SGFsbG8=” ist die Base64-Codierung von “Hallo”."
  },
  {
    "objectID": "files/lektionen_fs25/250319/base64.html#anwendungen-der-base64-codierung",
    "href": "files/lektionen_fs25/250319/base64.html#anwendungen-der-base64-codierung",
    "title": "Base64-Codierung",
    "section": "Anwendungen der Base64-Codierung",
    "text": "Anwendungen der Base64-Codierung\n\nE-Mail-Anhänge (MIME)\nDatenkodierung in URLs\nEinbettung von Bildern in HTML/CSS (Data-URLs)\nÜbertragung binärer Daten in JSON\nSpeicherung von Binärdaten in XML\n\nBase64 vergrößert die Datenmenge um etwa 33% (da 3 Bytes in 4 Zeichen umgewandelt werden), bietet aber den Vorteil, dass die codierten Daten in jedem Textformat sicher übertragen werden können."
  },
  {
    "objectID": "files/lektionen_fs25/250226/binaersystem.html",
    "href": "files/lektionen_fs25/250226/binaersystem.html",
    "title": "Das Binärsystem",
    "section": "",
    "text": "Wir sind es gehwont uns im Dezimalsystem zu bewegen. Das bedeutet, dass wir Zahlen in der Basis 10 darstellen. Wir verwenden dazu 10 verschiedene Ziffern, nämlich die Ziffern 0 bis 9.\nUm Zahlen darzustellen, welche grösser sind als 9 darzustellen, verwednen wir die Zehnerpotenzen. Das heisst, dass die Ziffern von rechts nach links gelesen, die Zehnerpotenzen von 0 an aufsteigend sind. Die Zahl 123 entspricht also der Rechnung \\(1 \\cdot 10^2 + 2 \\cdot 10^1 + 3 \\cdot 10^0\\).\nDas Binärsystem funktioniert nach dem gleichen Prinzip, nur dass wir nur die Ziffern 0 und 1 verwenden. Das bedeutet, dass wir Zahlen in der Basis 2 darstellen. Sobald eine Zahl grösser als 1 dargestellt werden soll, schreiben wir die Zahl als Summe von Zweierpotenzen. Die Zahl 101 entspricht also der Rechnung \\(1 \\cdot 2^2 + 0 \\cdot 2^1 + 1 \\cdot 2^0\\)."
  },
  {
    "objectID": "files/lektionen_fs25/250226/binaersystem.html#umrechnung-von-dezimalzahlen-in-binärzahlen",
    "href": "files/lektionen_fs25/250226/binaersystem.html#umrechnung-von-dezimalzahlen-in-binärzahlen",
    "title": "Das Binärsystem",
    "section": "Umrechnung von Dezimalzahlen in Binärzahlen",
    "text": "Umrechnung von Dezimalzahlen in Binärzahlen\nUm eine Dezimalzahl in eine Binärzahl umzurechnen, gibt es eine systematische Methode, die auf wiederholter Division durch 2 basiert:\n\nTeile die Dezimalzahl durch 2 und notiere den Rest (0 oder 1).\nTeile den Quotienten (Ergebnis der Division) erneut durch 2 und notiere wieder den Rest.\nFahre damit fort, bis der Quotient 0 ist.\nDie Binärzahl wird nun gebildet, indem man die Reste von unten nach oben (vom letzten zum ersten) liest.\n\n\nBeispiel: Umrechnung von 42 ins Binärsystem\nLassen Sie uns die Dezimalzahl 42 in eine Binärzahl umrechnen:\n\n\n\nDivision\nRechnung\nQuotient\nRest\n\n\n\n\n42 ÷ 2\n42 = 21 · 2 + 0\n21\n0\n\n\n21 ÷ 2\n21 = 10 · 2 + 1\n10\n1\n\n\n10 ÷ 2\n10 = 5 · 2 + 0\n5\n0\n\n\n5 ÷ 2\n5 = 2 · 2 + 1\n2\n1\n\n\n2 ÷ 2\n2 = 1 · 2 + 0\n1\n0\n\n\n1 ÷ 2\n1 = 0 · 2 + 1\n0\n1\n\n\n\nNun lesen wir die Reste von unten nach oben: 101010\nAlso ist 42 im Dezimalsystem gleich 101010 im Binärsystem.\n\n\nÜberprüfung:\n\\(1 \\cdot 2^5 + 0 \\cdot 2^4 + 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 0 \\cdot 2^0\\) \\(= 32 + 0 + 8 + 0 + 2 + 0 = 42\\)\nEine alternative Methode zur Umrechnung ist die Verwendung der Zweierpotenzen. Man zerlegt die Dezimalzahl in eine Summe von Zweierpotenzen und schreibt dann eine 1 an den Stellen der verwendeten Potenzen und eine 0 an allen anderen Stellen."
  },
  {
    "objectID": "files/lektionen_fs25/250226/binaersystem.html#umrechnung-von-binärzahlen-in-dezimalzahlen",
    "href": "files/lektionen_fs25/250226/binaersystem.html#umrechnung-von-binärzahlen-in-dezimalzahlen",
    "title": "Das Binärsystem",
    "section": "Umrechnung von Binärzahlen in Dezimalzahlen",
    "text": "Umrechnung von Binärzahlen in Dezimalzahlen\nDie Umrechnung von Binärzahlen in Dezimalzahlen ist vergleichsweise einfach und basiert auf der Berechnung der Stellenwerte im Binärsystem.\n\nMethode:\n\nIdentifiziere jede Stelle in der Binärzahl und ihre Position (von rechts nach links beginnend bei 0).\nMultipliziere jede Binärziffer (0 oder 1) mit dem Wert von 2 hoch der Stellenposition.\nAddiere alle resultierenden Werte zusammen.\n\n\n\nBeispiel: Umrechnung von 10110₂ ins Dezimalsystem\nLassen Sie uns die Binärzahl 10110 in eine Dezimalzahl umrechnen:\n\n\n\nPosition (von rechts)\n4\n3\n2\n1\n0\n\n\n\n\nBinäre Ziffer\n1\n0\n1\n1\n0\n\n\nBerechnung\n1 · 2⁴\n0 · 2³\n1 · 2²\n1 · 2¹\n0 · 2⁰\n\n\nDezimalwert\n16\n0\n4\n2\n0\n\n\n\nNun addieren wir alle Dezimalwerte: 16 + 0 + 4 + 2 + 0 = 22\nAlso ist 10110₂ im Binärsystem gleich 22 im Dezimalsystem.\n\n\nFormel:\nFür eine Binärzahl mit n Stellen (b₀, b₁, …, bₙ₋₁) gilt:\nDezimalzahl = b₀ · 2⁰ + b₁ · 2¹ + b₂ · 2² + … + bₙ₋₁ · 2ⁿ⁻¹\nwobei b₀ die erste Stelle von rechts ist.\n\n\nPraktischer Trick:\nBei der Umrechnung kann man auch eine Tabelle mit den Stellenwerten erstellen:\n\n\n\n2⁷\n2⁶\n2⁵\n2⁴\n2³\n2²\n2¹\n2⁰\n\n\n\n\n128\n64\n32\n16\n8\n4\n2\n1\n\n\n\nMan schreibt die Binärzahl unter die Tabelle und addiert nur die Werte, an deren Position eine 1 steht."
  },
  {
    "objectID": "files/lektionen_fs25/250226/binaersystem.html#binärcodierung-von-strings",
    "href": "files/lektionen_fs25/250226/binaersystem.html#binärcodierung-von-strings",
    "title": "Das Binärsystem",
    "section": "Binärcodierung von Strings",
    "text": "Binärcodierung von Strings\nIn der Informatik werden Textzeichen (Strings) durch binäre Codes repräsentiert. Bei Unicode-Zeichen wird eine fortschrittliche Codierung verwendet, um sowohl einfache als auch komplexe Schriftzeichen aus allen Sprachen der Welt darstellen zu können.\n\nUnicode: Ein universeller Zeichencode\nUnicode ist ein internationaler Standard zur Darstellung von Textzeichen aller Schriftsysteme. Jedes Zeichen erhält eine eindeutige Nummer (Codepoint), z.B. hat der Buchstabe “A” den Codepoint U+0041 (dezimal: 65).\n\n\nUTF-8: Die häufigste Unicode-Codierung\nUTF-8 ist die am weitesten verbreitete Codierungsform für Unicode. Sie hat folgende Eigenschaften:\n\nVariable Länge: Ein Zeichen wird mit 1 bis 4 Bytes codiert\nAbwärtskompatibilität: ASCII-Zeichen (0-127) werden mit nur 1 Byte dargestellt\nSelbstsynchronisierend: Der Anfang eines Zeichens ist eindeutig erkennbar\n\n\n\nUTF-8 Codierungsschema:\n\n\n\nAnzahl Bytes\nBinärmuster\nCodepoint-Bereich\n\n\n\n\n1\n0xxxxxxx\nU+0000 bis U+007F\n\n\n2\n110xxxxx 10xxxxxx\nU+0080 bis U+07FF\n\n\n3\n1110xxxx 10xxxxxx 10xxxxxx\nU+0800 bis U+FFFF\n\n\n4\n11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\nU+10000 bis U+10FFFF\n\n\n\nDie mit x markierten Stellen werden mit den Bits des Unicode-Codepoints gefüllt.\n\n\nBeispiel: Codierung deutscher Umlaute\nNehmen wir als Beispiel den Buchstaben “ü” (U+00FC):\n\nDer Codepoint von “ü” ist U+00FC (dezimal: 252)\nAls Binärzahl: 11111100\nDa der Wert &gt; 127 ist, benötigen wir 2 Bytes\nNach dem 2-Byte-Schema: 110xxxxx 10xxxxxx\nWir füllen den Unicode-Wert ein: 110(00000) 10(111100) → 11000011 10111100\nSomit wird “ü” als die zwei Bytes 11000011 10111100 codiert\n\n\n\nWeiteres Beispiel: Das Pi-Symbol π\n\nDer Codepoint von “π” ist U+03C0 (dezimal: 960)\nAls Binärzahl: 0000001111000000\nDa der Wert &gt; 127 und &lt; 2048 ist, benötigen wir 2 Bytes\nNach dem 2-Byte-Schema: 110xxxxx 10xxxxxx\nWir füllen den Unicode-Wert ein: 110(00111) 10(100000) → 11000111 10100000\nSomit wird “π” als die zwei Bytes 11000111 10100000 codiert (hexadezimal: CE A0)\n\n\n\nBeispiel: ‘Informatik ist interessant.’\nLassen Sie uns den Satz “Informatik ist interessant.” in die binäre UTF-8-Kodierung umwandeln:\n\n\n\nZeichen\nUnicode-Codepoint\nDezimal\nBinär\nUTF-8 Kodierung\n\n\n\n\nI\nU+0049\n73\n1001001\n01001001\n\n\nn\nU+006E\n110\n1101110\n01101110\n\n\nf\nU+0066\n102\n1100110\n01100110\n\n\no\nU+006F\n111\n1101111\n01101111\n\n\nr\nU+0072\n114\n1110010\n01110010\n\n\nm\nU+006D\n109\n1101101\n01101101\n\n\na\nU+0061\n97\n1100001\n01100001\n\n\nt\nU+0074\n116\n1110100\n01110100\n\n\ni\nU+0069\n105\n1101001\n01101001\n\n\nk\nU+006B\n107\n1101011\n01101011\n\n\n␣\nU+0020\n32\n100000\n00100000\n\n\ni\nU+0069\n105\n1101001\n01101001\n\n\ns\nU+0073\n115\n1110011\n01110011\n\n\nt\nU+0074\n116\n1110100\n01110100\n\n\n␣\nU+0020\n32\n100000\n00100000\n\n\ni\nU+0069\n105\n1101001\n01101001\n\n\nn\nU+006E\n110\n1101110\n01101110\n\n\nt\nU+0074\n116\n1110100\n01110100\n\n\ne\nU+0065\n101\n1100101\n01100101\n\n\nr\nU+0072\n114\n1110010\n01110010\n\n\ne\nU+0065\n101\n1100101\n01100101\n\n\ns\nU+0073\n115\n1110011\n01110011\n\n\ns\nU+0073\n115\n1110011\n01110011\n\n\na\nU+0061\n97\n1100001\n01100001\n\n\nn\nU+006E\n110\n1101110\n01101110\n\n\nt\nU+0074\n116\n1110100\n01110100\n\n\n.\nU+002E\n46\n101110\n00101110\n\n\n\nDa alle Zeichen in diesem Beispiel im ASCII-Bereich liegen (0-127), wird jedes Zeichen mit genau einem Byte codiert. Der vollständige Text benötigt also 27 Bytes im UTF-8 Format.\nDie komplette binäre Darstellung des Textes ist:\n01001001 01101110 01100110 01101111 01110010 01101101 01100001 01110100 \n01101001 01101011 00100000 01101001 01110011 01110100 00100000 01101001 \n01101110 01110100 01100101 01110010 01100101 01110011 01110011 01100001 \n01101110 01110100 00101110\nIn hexadezimaler Schreibweise:\n49 6E 66 6F 72 6D 61 74 69 6B 20 69 73 74 20 69 6E 74 65 72 65 73 73 61 6E 74 2E\nDieser String kann direkt in einem Computer gespeichert und verarbeitet werden. In Textdateien, bei der Übertragung im Internet oder in Datenbanken sind Strings immer in solchen binären Formaten gespeichert.\n\n\nVorteile der Unicode-Codierung:\n\nUniversalität: Alle Schriftsysteme und Sonderzeichen können dargestellt werden\nEffizienz: Häufig verwendete Zeichen benötigen weniger Speicherplatz\nKompatibilität: Rückwärtskompatibel mit ASCII, was die Integration erleichtert\n\nDie Umwandlung zwischen Textzeichen und ihrer binären Repräsentation wird in Computersystemen automatisch durch Codierungs- und Decodierungsprozesse abgewickelt, sodass Benutzer sich in der Regel nicht mit den Details befassen müssen."
  },
  {
    "objectID": "files/HS_25.html",
    "href": "files/HS_25.html",
    "title": "Autumn Term Materials 2025/2026",
    "section": "",
    "text": "Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nAuthor\n\n\n\n\n\n\n\n\n20.08.2025\n\n\n1 Computer Networks\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n20.08.2025\n\n\n2 IP Addresses and DNS\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n20.08.2025\n\n\n3 Network Address Translation (NAT)\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n20.08.2025\n\n\n4 Top-level domains and their allocation\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n27.08.2025\n\n\n5 Monitoring Internet connections\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n03.09.2025\n\n\n6 Python Sockets: A Simple Client-Server Example\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n10.09.2025\n\n\n7 File Handling\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n10.09.2025\n\n\n8 Caesar Cipher\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n17.09.2025\n\n\n9 Polyalphabetic Ciphers\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n23.09.2025\n\n\n10 Vigenère Cipher Implementation in Python\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n24.09.2025\n\n\n11 Breaking the Vigenère Cipher\n\n\nJacques Mock Schindler\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "files/FS_25.html",
    "href": "files/FS_25.html",
    "title": "Spring Term Materials 2025",
    "section": "",
    "text": "Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nAuthor\n\n\n\n\n\n\n\n\n19.02.2025\n\n\nQueues in Python\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n26.02.2025\n\n\nDas Binärsystem\n\n\nJacques Mock Schindler\n\n\n\n\n\n\nInvalid Date\n\n\nBinary Search Tree\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n19.03.2025\n\n\nBase64-Codierung\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n26.03.2025\n\n\nLernziele für die Prüfung vom 26. März 2025\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n16.04.2025\n\n\nEinführung in Datenbanken\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n07.05.2025\n\n\nAbfrage von Daten\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n21.05.2025\n\n\nLernziele für die Prüfung vom 21. Mai 2025\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "files/HS_24.html",
    "href": "files/HS_24.html",
    "title": "Autumn Term Materials 2024/2025",
    "section": "",
    "text": "Order By\n      Default\n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n      \n        Title\n      \n      \n        Author\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\n\nTitle\n\n\n\nAuthor\n\n\n\n\n\n\n\n\n21.08.2024\n\n\nWas ist Informatik?\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n28.08.2024\n\n\nErforderliche Systemeinrichtungen\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n04.09.2024\n\n\nProbleme lösen\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n11.09.2024\n\n\nVariablen und Datentypen in Python\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n18.09.2024\n\n\nWiederholungen in Python\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n25.09.2024\n\n\nBedingungen in Python\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n23.10.2024\n\n\nAnwendungsübung und Prüfungsvorbereitung\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n13.11.2024\n\n\nDatenstrukturen in Python: Listen\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n20.11.2024\n\n\nPython Dictionaries\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n27.11.2024\n\n\nAlgorithmen\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n04.12.2024\n\n\nRekursion\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n11.12.2024\n\n\nAnwendungsübung zur Rekursion\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n18.12.2024\n\n\nLernziele für die Prüfung vom 8. Januar 2025\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n15.01.2025\n\n\nBinary Search Tree\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n22.01.2025\n\n\nDatenstrukturen Stack und Queue\n\n\nJacques Mock Schindler\n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n \n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "files/lektionen_fs25/250219/queue.html",
    "href": "files/lektionen_fs25/250219/queue.html",
    "title": "Queues in Python",
    "section": "",
    "text": "Queues sind Datenstrukturen, welche Daten speichern und grundsätzlich in der Reihenfolge, in der sie abgespeichert worden sind, wieder zurückgeben (First In - First Out, FIFO). Eine Queue ist eine derart fundamentale Datenstruktur, dass Python sie als Library zur Verfügung stellt.\nUm zu verstehen, wie eine Queue funktioniert, geht es im folgenden darum, eine eigene Klasse Queue in Python zu implementieren.\nZu Beginn ist zu überlegen, welche Eigenschaften, die Queue aufweisen muss. Sie muss Daten abspeichern und diese in der gleichen Reihenfolge wieder ausgeben können. Wir brauchen also eine Struktur für die Daten und eine Struktur, welche die Reihenfolge der Speicherung festhält. Die Struktur, welche die Reihenfolge festhält, muss ausserdem in der Lage sein, neue Daten abzuspeichern und bereits abgespeicherte Daten wieder zurückzugeben. Diese Anforderungen können mit Hilfe bereits programmierter Klassen umgesetzt werden. Um die Daten abzuspeichern können wir Nodes verwenden und für die Struktur zum Erhalt der Reihenfolge die Linke List.\nIn der aktuellen Implementation der Linked List gibt es nur einen Positionsbezug auf das letzte eingefügte Element (self.root). Damit die Linked List als Queue verwendet werden kann, muss auch ein Bezug auf das erste eingefügte Element angelegt werden (self.head). Für das Erste überhaupt in die Datenstruktur eingefügte Element ist dies kein Problem. Wenn aber weitere Elemente eingefügt oder entfernt werden, dann muss in den einzelnen Nodes nicht nur ein Bezug auf das folgende Element (self.connections['next']) sondern auch einer auf das Vorangehende Element (self.connections['previous']). Entsprechend müssen die beiden Klassen Node und Linked List angepasst werden.\nDas kann umgesetzt werden, in dem basierend auf den bereits existierenden Klassen abgeleitete Klassen implementiert werden. Als UML-Klassendiagramm sieht das folgendermassen aus:\n\nFür die Umsetzung der obigen Ausführungen stehen hier zwei Module (linked_list.py und nodes.py) zur Verfügung."
  },
  {
    "objectID": "files/lektionen_fs25/250305/bst.html",
    "href": "files/lektionen_fs25/250305/bst.html",
    "title": "Binary Search Tree",
    "section": "",
    "text": "Ein binärer Suchbaum (Binary Search Tree, BST) ist eine Datenstruktur, die es ermöglicht, Daten in einer hierarchischen Struktur zu speichern. Jeder Knoten im Baum hat maximal zwei Kinder, wobei das linke Kind kleiner und das rechte Kind grösser als der Knoten selbst ist. Dies ermöglicht das effiziente Suchen, Einfügen und Löschen von Elementen.\nSollen beispielsweise die Zahlen 42, 23, 17, 34, 56, 78 und 12 der Reihe nach in einen binären Suchbaum eingefügt werden, geschieht dies wie folgt:\nUm einen Knoten zu löschen, gibt es drei Fälle zu beachten: 1. Der Knoten ist ein Blatt (keine Kinder): Der Knoten kann einfach entfernt werden. 2. Der Knoten hat ein Kind: Das Kind ersetzt den Knoten. 3. Der Knoten hat zwei Kinder: Der Knoten wird durch den kleinsten Knoten im rechten Teilbaum ersetzt.\nIn den folgenden Abschnitten findet sich eine Mögliche Implementierung eines binären Suchbaums in Python."
  },
  {
    "objectID": "files/lektionen_fs25/250305/bst.html#klasse-bstnode",
    "href": "files/lektionen_fs25/250305/bst.html#klasse-bstnode",
    "title": "Binary Search Tree",
    "section": "Klasse BSTNode",
    "text": "Klasse BSTNode\n\nclass BSTNode:\n    def __init__(self, key, value=None):\n        self.key = key\n        self.value = value\n        self.parent = None\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        key = str(self.key)\n        parent = 'None' if self.parent is None else str(self.parent.key)\n        left = 'None' if self.left is None else str(self.left.key)\n        right = 'None' if self.right is None else str(self.right.key)\n        s = (\n            f'\\tParent = {parent}\\n'\n            f'\\tKey = {key}\\n'\n            f'Left = {left}\\tRight = {right}'\n        )\n        return s"
  },
  {
    "objectID": "files/lektionen_fs25/250305/bst.html#klasse-bst",
    "href": "files/lektionen_fs25/250305/bst.html#klasse-bst",
    "title": "Binary Search Tree",
    "section": "Klasse BST",
    "text": "Klasse BST\n\nclass BST:\n    def __init__(self, key=None, value=None):\n        if key is None:\n            self.root = None\n        else:\n            node = BSTNode(key, value)            \n            self.root = node\n            \n    def insert(self, key, value=None, root=None):\n        node = BSTNode(key, value)\n        if self.root is None:\n            self.root = node\n            return\n\n        if root is None:\n            root = self.root\n        \n        if key &lt; root.key and root.left is None:\n            root.left = node\n            node.parent = root\n            return\n\n        if key &lt; root.key:\n            root = root.left\n            self.insert(key, value, root)\n            \n        \n        if key &gt; root.key and root.right is None:\n            root.right = node\n            node.parent = root\n            return\n\n        if key &gt; root.key:\n            root = root.right\n            self.insert(key, value, root)\n\n    def min(self, bst=None):\n        if bst is None:\n            minimum = self.root\n        else:\n            minimum =bst.root\n        \n        while minimum.left is not None:\n            minimum = minimum.left\n        \n        return minimum\n\n    def max(self, bst=None):\n        if bst is None:\n            maximum = self.root\n        else:\n            maximum = bst.root\n\n        while maximum.right is not None:\n            maximum = maximum.right\n\n        return maximum\n\n    def search(self, key, node=None):\n        # If initial call or we've hit None in recursion\n        if node is None:\n            if self.root is None:  # Empty tree\n                return -1\n            node = self.root\n        \n        # Found the key\n        if key == node.key:\n            return node\n            \n        # Key doesn't exist in this path\n        if key &lt; node.key:\n            if node.left is None:\n                return -1\n            return self.search(key, node.left)\n        else:  # key &gt; node.key\n            if node.right is None:\n                return -1\n            return self.search(key, node.right)\n\n    def delete(self, key):\n        # Find the node to delete\n        node = self.search(key)\n        \n        # If node not found, return\n        if node == -1:\n            return\n        \n        self._delete_node(node)\n        \n    def _delete_node(self, node):\n        # Case 1: Node has no children (leaf node)\n        if node.left is None and node.right is None:\n            if node == self.root:\n                self.root = None\n            else:\n                if node.parent.left == node:\n                    node.parent.left = None\n                else:\n                    node.parent.right = None\n        \n        # Case 2: Node has only one child\n        elif node.left is None:  # Has only right child\n            if node == self.root:\n                self.root = node.right\n                node.right.parent = None\n            else:\n                if node.parent.left == node:\n                    node.parent.left = node.right\n                else:\n                    node.parent.right = node.right\n                node.right.parent = node.parent\n        \n        elif node.right is None:  # Has only left child\n            if node == self.root:\n                self.root = node.left\n                node.left.parent = None\n            else:\n                if node.parent.left == node:\n                    node.parent.left = node.left\n                else:\n                    node.parent.right = node.left\n                node.left.parent = node.parent\n        \n        # Case 3: Node has two children\n        else:\n            # Find successor (smallest node in right subtree)\n            successor = None\n            current = node.right\n            \n            while current.left is not None:\n                current = current.left\n            \n            successor = current\n            \n            # Copy successor's key and value to the node\n            node.key = successor.key\n            node.value = successor.value\n            \n            # Delete the successor (which has at most one right child)\n            self._delete_node(successor)\n        \n    def iterate(self, node=None, result=None):\n        # Initialize result list on first call\n        if result is None:\n            result = []\n        \n        # Use root if no starting node provided\n        if node is None:\n            if self.root is None:  # Empty tree\n                return result\n            node = self.root\n        \n        # In-order traversal: left -&gt; current -&gt; right\n        if node.left is not None:\n            self.iterate(node.left, result)\n        \n        result.append(node)\n        \n        if node.right is not None:\n            self.iterate(node.right, result)\n        \n        return result"
  },
  {
    "objectID": "files/lektionen_fs25/250326/lernziele.html",
    "href": "files/lektionen_fs25/250326/lernziele.html",
    "title": "Lernziele für die Prüfung vom 26. März 2025",
    "section": "",
    "text": "Ich erwarte, dass Sie in der Lage sind,\n\ndie folgenden Datenstrukturen zu beschreiben und ihre Implementation in Python grundsätzlich zu erklären:\n\nLinked List\nStack\nQueue sowie\nBinary Search Tree;\n\nZahlen vom Dezimalsystem ins Binärsystem umzurechnen und umgekehrt sowie\nzu erklären, wozu die Base64-Codierung verwendet wird und wie sie funktioniert.\n\nAnd der Prüfung dürfen Sie eine handschriftliche Zusammenfassung im Umfang von einer Seite A4 verwenden. Das einzige, was nicht auf der Zusammenfassung stehen darf, sind die für das Arbeiten mit Jupyter Notebooks notwendigen Einrichtungsschritte."
  },
  {
    "objectID": "files/lektionen_fs25/250507/sql.html",
    "href": "files/lektionen_fs25/250507/sql.html",
    "title": "Abfrage von Daten",
    "section": "",
    "text": "Datenbanken werden mit einer spezifischen Datenbanksprache angesprochen. Im Gegensatz zur bisher im Unterricht verwendeten Programmiersprache Python ist die Datenbanksprache SQL (Structured Query Language) eine deklarative Sprache. In Python werden die Befehle grundsätzlich der Reihe nach abgearbeitet. In SQL wird das gewünschte Resultat beschrieben. Wie diese Beschreibung abgearbeitet wird, ist in den Grundlagen der Datenbank programmiert."
  },
  {
    "objectID": "files/lektionen_fs25/250507/sql.html#grundstruktur-einer-sql-abfrage",
    "href": "files/lektionen_fs25/250507/sql.html#grundstruktur-einer-sql-abfrage",
    "title": "Abfrage von Daten",
    "section": "Grundstruktur einer SQL Abfrage",
    "text": "Grundstruktur einer SQL Abfrage\nDie Grundstruktur einer SQL Abfrage ist im untenstehenden Code Snippet dargestellt.\nSELECT &lt;Spalten&gt; \nFROM &lt;Tabelle&gt; \nWHERE &lt;Bedingung&gt;;\nDas Schlüsselwort SELECT gibt an, welche Spalten aus der Tabelle ausgeben werden soll(en). Das Schlüsselwort FROM gibt an, aus welcher Tabelle die Daten ausgelesen werden. Das Schlüsselwort WHERE gibt die Bedingung an, die erfüllt sein muss, damit die Daten angezeigt werden. Dass die Schlüsselwörter in Grossbuchstaben geschrieben werden, ist technisch nicht nötig, entspricht aber der Konvention. Die Abfrage wird mit einem Semikolon abgeschlossen.\n\nEinfache Abfrage\nIn einem ersten Beispiel sollen alle Vornamen aller Lehrer aus der Tabelle Lehrer aus dem vergangenen Abschnitt angezeigt werden:\nSELECT Vorname\nFROM Lehrer;\nIn diesem Beispiel wurde auf die Formulierung einer Bedingung verzichtet. Wenn die Ausgabe zusätzlich eine Bedingung erfüllen soll, wird diese mit dem Schlüsselwort WHERE angegeben. Im folgenden Beispiel sollen nur die Vornamen der Lehrer angezeigt werden, die vor dem Jahr 1800 geboren sind.\n\n\nAbfrage mit Bedingung\nSELECT Vorname\nFROM Lehrer\nWHERE Geburtsdatum &lt; '1800-01-01';\nDiese Abfrage führt zu folgendem Ergebnis:\n\n\n\nVorname\n\n\n\n\nFriedrich\n\n\nHonore de\n\n\nJohann Carl Friedrich\n\n\nGuillaume-Henri\n\n\n\n\n\nSortierung der Ausgabe\nFalls die Ausgabe nicht nur die Vornamen, sondern auch die Nachnamen und das Geburtsdatum enthalten soll und die Ausgabe nach dem Geburtsdatum aufsteigend sortiert werden soll, wird die Abfrage entsprechend angepasst:\nSELECT Name, Vorname, Geburtsdatum\nFROM Lehrer\nWHERE Geburtsdatum &lt; '1800-01-01'\nORDER BY Geburtsdatum;\nDiese Abfrage führt zu folgendem Ergebnis:\n\n\n\nName\nVorname\nGeburtsdatum\n\n\n\n\nSchiller\nFriedrich\n10.11.1759\n\n\nGauss\nJohann Carl Friedrich\n30.04.1777\n\n\nDufour\nGuillaume-Henri\n15.09.1787\n\n\nBalzac\nHonoré de\n20.05.1799\n\n\n\nEs können dem Schlüsselwort SELECT mehrere Spalten übergeben werden. Zusätzlich wurde in der Anfrage das Schlüsselwort ORDER BY verwendet. Mit diesem kann angegeben werden, nach welchem Kriterium die Ausgabe sortiert werden soll. Standardmässig wird aufsteigend sortiert. Mit dem Schlüsselwort DESC kann die Sortierung absteigend erfolgen. Die Abfrage sieht dann folgendermassen aus:\nSELECT Name, Vorname, Geburtsdatum\nFROM Lehrer\nWHERE Geburtsdatum &lt; '1800-01-01'\nORDER BY Geburtsdatum DESC;\nDie Sortierreihenfolge wird hinter das Kriterium geschrieben. Wenn nach mehreren Kriterien sortiert werden soll, werden die zusätzlichen Kriterien mit einem Komma an das erste Kriterium angehängt."
  },
  {
    "objectID": "files/lektionen_fs25/250507/sql.html#abfrage-aus-mehreren-tabellen",
    "href": "files/lektionen_fs25/250507/sql.html#abfrage-aus-mehreren-tabellen",
    "title": "Abfrage von Daten",
    "section": "Abfrage aus mehreren Tabellen",
    "text": "Abfrage aus mehreren Tabellen\nInteressanter, als die Abfrage von Daten aus einer einzigen Tabelle, ist die Abfrage aus mehreren Tabellen. So ist es im Beispiel möglich, Abzufragen, wer Deutsch unterrichtet. Aus diesem Grund wurde die Tabelle erhält Unterricht in/von angelegt.\n\n\n\nerhält Unterricht in/von\n\n\nUm abzufragen, wer Deutsch unterrichtet, müssen die Daten aus den Tabellen Lehrer, Fach und erhält Unterricht in/von zusammengeführt werden. Dies geschieht mit dem Schlüsselwort JOIN. Das Schlüsselwort JOIN kann unterschiedlich verwendet werden. Im vorliegenden Beispiel wird die Variante INNER JOIN verwendet.\nSELECT DISTINCT l.Name, l.Vorname\nFROM Lehrer AS l\nINNER JOIN erhält_Unterricht_in AS u ON l.Personalnummer = u.Personalnummer\nWHERE u.Fach_ID = 'Deutsch';\nDas Resultat dieser Abfrage sieht wie folgt aus:\n\n\n\nName\nVorname\n\n\n\n\nSchiller\nFriedrich\n\n\n\nIn Ergänzung zu den bisherigen Abfragen, kommt neu das Schlüsselwort DISTINCT zum Einsatz. Dieses bewirkt, dass Daten, die mehrfach vorkommen, nur einmal ausgegeben werden. In diesem Beispiel wäre dies nicht nötig, da es nur einen Lehrer gibt, der Deutsch unterrichtet.\nUnter dem Schlüsselwort FROM wird die Tabelle Lehrer mit dem Alias l angegeben. Der Alias wird verwendet, um die Abfrage leserlicher zu machen. Wenn mehrere Tabellen abgefragt werden, muss jede Spalte die Ausgeben werden soll, mit der Tabelle, aus der sie stammt, angegeben werden. Mit dem Alias kann dies abgekürzt werden. Das Schlüsselwort AS für den Alias ist nicht nötig, dient aber der besseren Lesbarkeit.\nMit dem Schlüsselwort INNER JOIN werden die Datensätze aus den beiden Tabellen Lehrer und erhält_Unterricht_in basierend auf übereinstimmenden Werten in der Spalte Personalnummer miteinander verbunden. Dabei entsteht eine neue Ergebnismenge, die alle Spalten beider Tabellen enthält, jedoch nur für diejenigen Zeilen, bei denen die Personalnummer in beiden Tabellen übereinstimmt.\nAus dieser Schnittmenge werden aus der Tabelle erhält Unterricht in/von die Lehrer ausgewählt, die Deutsch unterrichten. Dies geschieht mit dem Schlüsselwort WHERE und dem Kriterium u.Fach_ID = 'Deutsch'.\nDie Abfrage, wer die Klasse fP_24-28 in PPP unterrichtet, sieht wie folgt aus:\nSELECT l.Name, l.Vorname\nFROM Lehrer AS l\nINNER JOIN erhält_Unterricht_in AS u ON l.Personalnummer = u.Personalnummer\nWHERE u.Fach_ID = 'PPP' \nAND u.Klassen_ID = 'fP_24-28';\nDie Abfrage gibt folgendes Resultat zurück:\n\n\n\nName\nVorname\n\n\n\n\nPiaget\nJean\n\n\n\nGegenüber der Abfrage, wer Deutsch unterrichtet, wurde mit dem Schlüsselwort AND die zusätzliche Bedingung u.Klassen_ID = 'fP_24-28' hinzugefügt."
  },
  {
    "objectID": "files/lektionen_fs25/250507/sql.html#ausblick",
    "href": "files/lektionen_fs25/250507/sql.html#ausblick",
    "title": "Abfrage von Daten",
    "section": "Ausblick",
    "text": "Ausblick\nDer nächste Abschnitt dient dazu, SQL zu üben. Als Übungsplattform wird SQL Island genutzt. Diese Plattform ist unter sql-island.informatik.uni-kl.de zu finden."
  },
  {
    "objectID": "files/lektionen_hs24/240821/einfuehrung.html",
    "href": "files/lektionen_hs24/240821/einfuehrung.html",
    "title": "Was ist Informatik?",
    "section": "",
    "text": "Um diese Frage zu beantworten, hilft es vielleicht sich die Übersetzung des Begriffes ins Englische vor Augen zu führen - Computer Science.\nDie Informatik ist allso die Wissenschaft, die sich mit Computern befasst. Gemeint ist damit die wissenschaftliche Auseinandersetzungen mit Fragen der folgenden Art:\n\nWie sind Computer aufgebaut?\nWie werden Informationen im Computer verarbeitet, abgespeichert und dargestellt?\nWie funktioniert die Kommunikation zwischen Computern?\nWelche Auswirkungen haben Computer auf die Gesellschaft?\n\nDieser Fragenkatalog ist nicht abschliessend und lediglich beispielhaft.\nIn einer ersten Phase werden wir uns hauptsächlich mit der zweiten Frage auseinandersetzen. Dazu werden wir mit der Programmiesprache Python kleine Programme schreiben."
  },
  {
    "objectID": "files/lektionen_hs24/240904/problemloesung.html",
    "href": "files/lektionen_hs24/240904/problemloesung.html",
    "title": "Probleme lösen",
    "section": "",
    "text": "In dieser Einheit geht es darum, sich mit einer ersten Art der Problemlösung beim Programmieren auseinanderzusetzen.\nDie hier vorgeschlagene Vorgehensweise ist simpel. Man nimmt das Problem und unterteilt es solange in Teilprobleme, bis nur noch einfach zu lösende Teilprobleme übrigbleiben.\nZur Illustration soll gezeigt werden, wie die Französische Trikolore gezeichnet werden kann. Wird diese in ihre Einzelteile zerlegt bleiben drei gleichgrosse nebeneinander angeordnete Rechtecke in den Farben blau, weiss und rot. Entsprechend muss man die drei Rechtecke zeichnen und anschliessen nebeneinander anordnen.\nDamit Sie das an Ihrem Computer tun können, müssen die folgenden Vorbereitungsarbeiten erledigt werden (es wird vorausgesetzt, dass alle Systemeinrichtungsarbeiten aus der Lektion vom 28. August 24 erfolgreich abgeschlossen sind):\n\nLegen Sie im Ordner Informatik einen Unterordner 240904 an.\nKlicken Sie den neuen Ordner 240904 mit der rechten Maustaste an und wählen sie aus dem Kontextmenü weitere Optionen aus. In den weiteren Optionen wählen Sie In Terminal öffnen.\nIm neuen Terminal erstellen Sie eine Python Virtual Environment.\n...\\240904&gt; python -m venv venv\nStarten Sie die Python Virtual Environment.\n...\\240904&gt; venv\\Scripts\\activate\nInstallieren Sie in dieser Python Virtual Environment die Pakete jupyter und pytamaro.\n...\\240904&gt; python -m pip install jupyter pytamaro\nDieser Vorgang dauert einige Minuten.\nJetzt können Sie unter dem Link Arbeitsblatt das vorbereitete Jupyter Notebook in den neuen Ordner 240904 herunterladen.\nStarten Sie Jupyter Notebook\n...\\240904&gt; jupyter notebook\nÖffnen Sie das Jupyter Notebook mit Doppelklick auf den Dateinamen schweizerfahne.ipynb\nFolgen Sie den Anleitungen im Arbeitsblatt.\n\nDiese Vorgehensweise soll in diesem Arbeitsblatt am Wappen des Kantons Tessin und der Schweizerfahne geübt werden."
  },
  {
    "objectID": "files/lektionen_hs24/240918/main.html",
    "href": "files/lektionen_hs24/240918/main.html",
    "title": "Wiederholungen in Python",
    "section": "",
    "text": "Eine Stärke von Computerprogrammen ist die wiederholte Ausführung von Anweisungen. Viele Programmiersprachen stellen dafür ein Konstrukt mit dem Namen ‘For-Schleife’ zur Verfügung. Eine ‘For-Schleife’ funktioniert unabhängig von einer konkreten Programmiersprache folgendermassen:\nFÜR variable VON startwert BIS endwert [MIT schrittweite]\n    Anweisungen\nENDE FÜR\nÜbersetzt nach Python sieht das so aus:\nfor i in range(n):\n    do...\nstartwert BIS endwert [MIT schrittweite] wird dabei durch range(n) ausgedrückt. Dabei ist n der Endwert. Gezählt wird bis zum aber ohne den Endwert. Startwert und Schrittweite haben Vorgabewerte. Der Vorgabewert für den Start ist 0, derjenige der Schrittweite 1. Weil range() diese vorgegebenen Werte hat, müssen diese nicht explizit angegeben werden. Wenn der Startwert abweichend vom Vorgabewert festgelegt werden soll, kann dieser explizit angegeben werden. Der Aufruf von range() sieht dann so aus:\nrange(startwert, endwert)\nFalls eine von 1 abweichende Schrittweite festgelegt werden soll lautet der Aufruf\nrange(startwert, endwert, schrittweite)\nIn diesem Fall müssen neben dem Endwert sowohl der Startwert und die Schrittweite angegeben werden. Andernfalls kann nicht zwischen den einzelnen Angaben zu Endwert, Startwert und Schrittweite unterschieden werden.\nIm hier verlinkten Arbeitsblatt finden Sie ein paar Übungen zu Python For-Schleifen."
  },
  {
    "objectID": "files/lektionen_hs24/241023/main.html",
    "href": "files/lektionen_hs24/241023/main.html",
    "title": "Anwendungsübung und Prüfungsvorbereitung",
    "section": "",
    "text": "In zwei Wochen, am 6. November 24, findet Ihre erste Prüfung im Fach Informatik statt. Die Lektionen vom 23. und vom 30. Oktober 24 dienen der Vorbereitung der Prüfung. Am 23. Oktober 24 steht Ihnen dazu ein Arbeitsblatt für die Repetition zur Verfügung. Am 30. Oktober 24 sind Sie auf sich allein gestellt.\nAn der Prüfung erwarte ich, dass Sie in der Lage sind\n\ndie Schritte für die Inbetriebnahme eines Jupyter Notebooks in der richtigen Reihenfolge aufzuzählen;\nmit Variabeln zu arbeiten;\nfor-Schlaufen zu schreiben;\nden Wahrheitswert logischer Verknüpfungen zu beurteilen;\nBedingungen zu verwenden sowie\nmathematische Formeln als Funktionen in Python zu implementieren."
  },
  {
    "objectID": "files/lektionen_hs24/241023/main.html#orientierung",
    "href": "files/lektionen_hs24/241023/main.html#orientierung",
    "title": "Anwendungsübung und Prüfungsvorbereitung",
    "section": "",
    "text": "In zwei Wochen, am 6. November 24, findet Ihre erste Prüfung im Fach Informatik statt. Die Lektionen vom 23. und vom 30. Oktober 24 dienen der Vorbereitung der Prüfung. Am 23. Oktober 24 steht Ihnen dazu ein Arbeitsblatt für die Repetition zur Verfügung. Am 30. Oktober 24 sind Sie auf sich allein gestellt.\nAn der Prüfung erwarte ich, dass Sie in der Lage sind\n\ndie Schritte für die Inbetriebnahme eines Jupyter Notebooks in der richtigen Reihenfolge aufzuzählen;\nmit Variabeln zu arbeiten;\nfor-Schlaufen zu schreiben;\nden Wahrheitswert logischer Verknüpfungen zu beurteilen;\nBedingungen zu verwenden sowie\nmathematische Formeln als Funktionen in Python zu implementieren."
  },
  {
    "objectID": "files/lektionen_hs24/241023/main.html#absicht",
    "href": "files/lektionen_hs24/241023/main.html#absicht",
    "title": "Anwendungsübung und Prüfungsvorbereitung",
    "section": "Absicht",
    "text": "Absicht\nIch will, dass Sie in einer ersten Phase mit Hilfe des Arbeitsblatt für die Repetition Ihren aktuellen Wissenstand überprüfen und in einer zweiten Phase die erkannten Lücken schliessen."
  },
  {
    "objectID": "files/lektionen_hs24/241023/main.html#auftrag",
    "href": "files/lektionen_hs24/241023/main.html#auftrag",
    "title": "Anwendungsübung und Prüfungsvorbereitung",
    "section": "Auftrag",
    "text": "Auftrag\nVerfassen Sie eine Zusammenfassung für die Prüfung vom 6. November 24."
  },
  {
    "objectID": "files/lektionen_hs24/241023/main.html#besondere-anordnungen",
    "href": "files/lektionen_hs24/241023/main.html#besondere-anordnungen",
    "title": "Anwendungsübung und Prüfungsvorbereitung",
    "section": "Besondere Anordnungen",
    "text": "Besondere Anordnungen\n\nDie Prüfung wird auf Papier stattfinden.\nAls Hilfsmittel ist eine eigenhändig handschriftlich geschriebene Zusammenfassung im Umfang von einer Seite A4 zugelassen.\nDie Schritte für die Inbetriebnahme eines Jupyter Notebooks müssen auswendig gelernt werden und dürfen in der Zusammenfassung nicht aufgeführt werden.\nDie Zusammenfassung ist in einer Teams-Aufgabe abzugeben.\nDie Abgabe hat als PDF zu erfolgen.\nDie korrekte Abgabe wird mit zwei Punkten an die Prüfungsbeurteilung angerechnet.\nDie in Teams abgegebene Zusammenfassung muss mit der an der Prüfung verwendeten Zusammenfassung identisch sein.\nDas an der Prüfung verwendete Original der Zusammenfassung ist mit der Prüfung zusammen abzugeben."
  },
  {
    "objectID": "files/lektionen_hs24/241023/main.html#erreichbarkeit",
    "href": "files/lektionen_hs24/241023/main.html#erreichbarkeit",
    "title": "Anwendungsübung und Prüfungsvorbereitung",
    "section": "Erreichbarkeit",
    "text": "Erreichbarkeit\nSie erreichen mich via Teams. Fragen zum Auftrag und zur Prüfung werden ausschliesslich im Kanal Allgemein des Teams I_eW_24-28 beantwortet."
  },
  {
    "objectID": "files/lektionen_hs24/241120/dictionaries.html",
    "href": "files/lektionen_hs24/241120/dictionaries.html",
    "title": "Python Dictionaries",
    "section": "",
    "text": "In Python Dictionaries können ähnlich wie in Python-Listen eine Reihe von Elementen abgelegt werden. Anders als in Python-Listen werden die Elemente allerdings nicht über einen Index aufgerufen, sondern über einen Schlüssel. Man spricht daher von key - value Paaren."
  },
  {
    "objectID": "files/lektionen_hs24/241120/dictionaries.html#erstellen-eines-python-dictionary",
    "href": "files/lektionen_hs24/241120/dictionaries.html#erstellen-eines-python-dictionary",
    "title": "Python Dictionaries",
    "section": "Erstellen eines Python Dictionary",
    "text": "Erstellen eines Python Dictionary\nDas folgende Listing zeigt ein einfaches Beispiel für ein Python Dictionary.\ndefinitions = {\n    'list': 'Eine Python-Liste ist eine geordnete Ablage von Werten von beliebiger Länge.',\n    'dictionary': 'Ein dictionary in Python bietet die Möglichkeit, key-value Paare abzulegen.'\n}\nDie key - value Paare werden für die Erstellung eines Python Dictionary in geschweifte Klammern geschrieben. Die Verbindung von Schlüssel und Wert erfolgt durch die Verbindung mit einem Doppelpunkt (key: value). Als Schlüssel eignen sich dabei Strings, Tupel (werden noch erklärt), sowie Ganzzahlen. Wichtig ist, dass die Schlüssel aus unveränderlichen Datentypen bestehen.\nUm die Lesbarkeit des Codes zu verbessern, hat es sich als gängige Praxis etabliert, die Variabel, welcher das Dictionary zugewiesen wird auf einer separaten Zeile zu schreiben und anschliessend für jedes key - value Paar eine neue Zeile zu verwenden. Mehrere Elemente werden durch Kommata abgegrenzt."
  },
  {
    "objectID": "files/lektionen_hs24/241120/dictionaries.html#zugriff-auf-ein-element-in-einem-python-dictionary",
    "href": "files/lektionen_hs24/241120/dictionaries.html#zugriff-auf-ein-element-in-einem-python-dictionary",
    "title": "Python Dictionaries",
    "section": "Zugriff auf ein Element in einem Python Dictionary",
    "text": "Zugriff auf ein Element in einem Python Dictionary\nUm auf einen Eintrag in einem Dictionary zuzugreifen, verwendet man die Variabel mit anschliessenden eckigen Klammern, in denen der Schlüssel steht.\ndefinitions['list']\nDas obige Listing gibt entsprechend den dem Schlüssel list zugewiesenen Wert aus."
  },
  {
    "objectID": "files/lektionen_hs24/241120/dictionaries.html#direkt-über-ein-python-dictionary-iterieren",
    "href": "files/lektionen_hs24/241120/dictionaries.html#direkt-über-ein-python-dictionary-iterieren",
    "title": "Python Dictionaries",
    "section": "Direkt über ein Python Dictionary iterieren",
    "text": "Direkt über ein Python Dictionary iterieren\nUm über die Elemente eines Dictionary zu iterieren gibt es verschiedene Möglichkeiten. Die einfachste Möglichkeit bietet ein for-loop.\nfor key in definitions:\n    print(definitions[key])\nDiese Möglichkeit hat allerdings den Nachteil, dass nur der Wert und nicht der dazugehörige Schlüssel ausgegeben wird. Um dies zu korrigieren, muss der print()-Befehl angepasst werden.\nfor key in definitions:\n    print(key + ': ' + definitions[key])\nAlternativ kann auch ein f-String verwendet werden.\nfor key in definitions:\n    print(f'{key}: {definitions[key]}')"
  },
  {
    "objectID": "files/lektionen_hs24/241120/dictionaries.html#über-ein-python-dictionary-iterieren-mit-der-.items-methode",
    "href": "files/lektionen_hs24/241120/dictionaries.html#über-ein-python-dictionary-iterieren-mit-der-.items-methode",
    "title": "Python Dictionaries",
    "section": "Über ein Python Dictionary iterieren mit der .items() Methode",
    "text": "Über ein Python Dictionary iterieren mit der .items() Methode\nEine weitere Möglichkeit bietet eine in die Datenstruktur der Python Dictionaries integrierte Funktion.\ndefinitions.items()\nDiese Zeile gibt alle Elemente (items) des Dictionary aus.\nWenn die Darstellung noch etwas schöner sein soll, kann der Befehl mit einem for-loop kombiniert werden.\nfor item in definitions.items():\n    print(item)\nUm die Elemente nach Schlüssel und Wert getrennt auszugeben, kann der for-loop folgendermassen angepasst werden:\nfor item, value in definitions.items():\n    print(f'{key}: {value}')\nDie hier dargelegten theoretischen Ausführungen können in diesem  Arbeitsblatt  eingeübt werden.  Die Musterlösung zum Arbeitsblatt ist hier verlinkt."
  },
  {
    "objectID": "files/lektionen_hs24/241204/divide_and_conquer.html",
    "href": "files/lektionen_hs24/241204/divide_and_conquer.html",
    "title": "Rekursion",
    "section": "",
    "text": "Bevor ein etwas effizienterer Sortieralgorithmus als selection sort besprochen werden kann, muss ein weiteres Programmierverfahren eingeführt werden: Die Rekursion. Man spricht in diesem Zusammenhang gelegentlich auch von divide and conquer (teile und herrsche).\nDie Möglichkeiten und Grenzen der Rekursion soll mit Hilfe dreier Beispiele\n\nder Berechnung der Summe einer Sequenz aufsteigender Zahlen,\nder Berechnung des Produkts einer Sequenz aufsteigender Zahlen (\\(n!\\)) sowie\nder Fibonacci Zahlenfolge\n\naufgezeigt werden.\nWie Rekursion im Allgemeinen funktioniert, kann mit der folgenden Kindergeschichte aufgezeigt werden:\n\nEs isch e mal en Maa gsi, de hät en hole Zah gha. I dem Zah häts es Truckli gha und i däm Truckli häts es Briefli gha. I dem Briefli isch gstande, es isch e mal en Maa gsi, de hät en hole Zah gha. I dem Zah häts es Truckli gha und id däm Truckli häts es Briefli gha…\n\nRekursive Funktionen sind entsprechend Funktionen, die sich selber aufrufen.\nHier geht es zu einem Arbeitsblatt zu den rekursiven Funktionen.\nDie Musterlösung des Arbeitsblattes ist hier verlinkt."
  },
  {
    "objectID": "files/lektionen_hs24/241218/lernziele.html",
    "href": "files/lektionen_hs24/241218/lernziele.html",
    "title": "Lernziele für die Prüfung vom 8. Januar 2025",
    "section": "",
    "text": "Ich erwarte, dass Sie in der Lage sind\n\nPyhton Listen anzulegen;\nPython Dictionaries anzulegen;\nüber Listen und Dictionaries zu iterieren;\ndie Funktionsweise von Selection Sort bzw. Merge Sort zu beschreiben und bezüglich ihrer Effizienz miteinander zu vergleichen;\nPython Code, welcher selection sort bzw. merge sort implementiert zu erläutern sowie\neinfache rekursive Funktionen zu schreiben.\n\nAusserdem erwarte ich, dass Sie in der Lage sind, auf alles schon getestete zurückzugreifen.\nHier die überarbeitete Darstellung der Startsequenz:\n\n\n\nStartsequenz"
  },
  {
    "objectID": "files/lektionen_hs24/250122/speicherstrukturen.html",
    "href": "files/lektionen_hs24/250122/speicherstrukturen.html",
    "title": "Datenstrukturen Stack und Queue",
    "section": "",
    "text": "Zwei wichtige Datenstrukturen zur Lösung alltäglicher Probleme sind der Stack (Stapelspeicher) und Queue (Warteschlange). In beiden Datenstrukturen können mehrere Werte zwischengespeichert werden. Die beiden Speicherformen sollen hier kurz erläutert werden.\nIn einem Stack werden die gespeicherten Werte gestapelt. Wie in einem Stapel in der realen Welt, wird der letzte gespeicherte Wert zuoberst auf den Stapel gelegt. Ebenso wie in einem realen Stapel, können die gespeicherten Werte nur in umgekehrter Reihenfolge zu ihrer Speicherung wieder abgerufen werden (last in - first out; LIFO).\nEin Stack kann dazu verwendet werden, um die Verarbeitungsreihenfolge von Rechenoperationen in einem Programm abzubilden.\n\n\n\nMartin Mayer mit einem Stapel Brot (Quelle: Sasa Noël und Heike Grein, Brothandwerk, Aarau und München, 2021, Seite 50)\n\n\nIn einer Queue werden die gespeicherten Werte in einer Warteschlange eingereiht. Wie in einer Warteschlange in der realen Welt, wird jeder neu gespeicherte Wert hinten eingereiht. Beim Abrufen der gespeicherten Werte wird der zuerst gespeicherte Wert zuerst verarbeitet (first in - first out; FIFO).\nEine Queue kann dazu verwendet werden, eine Warteschlange abzubilden wie sie in Netzwerken für die Übermittlung von Datenpaketen gebraucht wird.\n\n\n\nDole Queue Great Depression (Quelle: https://view.genially.com/609aac10d34c960d5992809a/interactive-content-great-depression-breakout, besucht am 22.01.15).\n\n\nFür die Übungen finden Sie hier eine Klasse Node und eine Klasse Linked List zum Download."
  },
  {
    "objectID": "files/lektionen_hs25/250820/networks.html",
    "href": "files/lektionen_hs25/250820/networks.html",
    "title": "1 Computer Networks",
    "section": "",
    "text": "Computer networks are systems that enable computers and other devices to communicate with each other. Originally, they were primarily used for exchanging messages. Today, networks also enable the sharing of resources such as printers, files and Internet access. They form the basis for many everyday applications – from e-mails and video conferences to cloud services.\nA computer network consists of several interconnected devices (e.g. computers, smartphones, servers) that communicate via various transmission media such as cables or radio waves. Important objectives of a network are:\n* Efficient communication * Reliable availability of information * Security of data transmission\nRules and protocols are used in networks to enable communication. A well-known reference model for describing these processes is the Open Systems Interconnection (OSI) layer model. It divides network communication into seven layers that build on top of each other – from the physical transmission of data to the application layer, where programs such as web browsers or email clients operate."
  },
  {
    "objectID": "files/lektionen_hs25/250820/networks.html#the-osi-and-the-tcpip-model",
    "href": "files/lektionen_hs25/250820/networks.html#the-osi-and-the-tcpip-model",
    "title": "1 Computer Networks",
    "section": "The OSI and the TCP/IP model",
    "text": "The OSI and the TCP/IP model\nThe OSI model is a reference model. It helps to structure and understand the complex processes involved in data transmission. The seven layers (with typical data units, known as Protocol or Payload Data Units (PDUs)) at a glance:\n\nPhysical layer\n\nTransmits individual bits as electrical, optical or radio signals via the transmission medium (e.g. cable, radio).\nPDU: Bits\n\nData link layer\n\nEnsures local, frame-based transmission between directly connected devices; regulates access to the medium (medium access control, MAC).\nProvides error detection and, depending on the technology, simple error handling/retransmissions (e.g. for WLAN).\nPDU: Frames\n\nNetwork Layer\n\nForwarding packets across multiple networks (routing); addressing at the network level (e.g. IP addresses).\nExample protocol: Internet Protocol (IP).\nPDU: Packets\n\nTransport Layer\n\nProvides end-to-end transport between applications. Different protocols offer different services:\n\nTCP: reliable, ordered, connection-oriented; incl. flow and congestion control.\nUDP: connectionless, no guarantee of reliability or order.\nPDU: segments (TCP) or datagrams (UDP)\n\n\nSession Layer\n\nEstablishes, manages and terminates sessions between applications (e.g. session management, dialogue control).\n\nPresentation Layer\n\nTranslates data between representation formats (e.g. character encoding, serialisation) and can compress/encrypt data.\n\nApplication Layer\n\nProvides the interface to application programmes and application protocols (e.g. HTTP, SMTP, DNS).\n\n\nThe OSI layer model has not been implemented as a protocol stack in its pure form. In practice, the TCP/IP model (TCP = Transmission Control Protocol, IP = Internet Protocol) has become established.\nThe TCP/IP model consists of four layers that combine the functions of the OSI model:\n\nNetwork access layer (OSI: Physical and Data Link Layers)\n\nExamples: Ethernet, WLAN; MAC addresses; switches typically operate here.\nPDU: Frames\n\nInternet layer (OSI: Network Layer)\n\nExamples: IP, routing; routers operate here; IP addresses.\nPDU: Packets\n\nTransport layer (OSI: Transport Layer)\n\nExamples: TCP (reliable, ordered), UDP (connectionless); ports identify services.\nPDU: Segments (TCP) / Datagrams (UDP)\n\nApplication layer (OSI: Application, Presentation, and Session Layers)\n\nExamples: HTTP/HTTPS, SMTP, DNS. Encryption such as TLS is typically above the transport layer and is assigned to applications.\n\n\nThe TCP/IP model is now the basis for communication on the Internet and in most computer networks."
  },
  {
    "objectID": "files/lektionen_hs25/250820/networks.html#analogy-to-encapsulation-in-object-oriented-programming-oop",
    "href": "files/lektionen_hs25/250820/networks.html#analogy-to-encapsulation-in-object-oriented-programming-oop",
    "title": "1 Computer Networks",
    "section": "Analogy to encapsulation in object-oriented programming (OOP)",
    "text": "Analogy to encapsulation in object-oriented programming (OOP)\nThe layer model in network technology can be compared to the principle of encapsulation in object-oriented programming. In both cases, complex tasks are divided into clearly defined, independent units (layers or classes). Each layer in the network model has a precisely defined task and only communicates with the layer directly above or below it – similar to how a class in OOP hides its internal details and only interacts with other classes via defined interfaces.\nThis encapsulation reduces complexity, makes changes easier to implement and allows the individual components to remain independently maintainable. Just as a class encapsulates its data and methods in OOP, each layer in the layer model encapsulates the details of its function and provides only the necessary services for the next layer."
  },
  {
    "objectID": "files/lektionen_hs25/250820/tld.html",
    "href": "files/lektionen_hs25/250820/tld.html",
    "title": "4 Top-level domains and their allocation",
    "section": "",
    "text": "Top-level domains (TLDs) are the last part of a domain name – the part after the last dot. In the address www.example.com, ‘.com’ is the top-level domain. TLDs form the highest hierarchical level in the Domain Name System (DNS) and are essential for the organisation of the Internet.\nEvery domain name follows a hierarchical structure that is read from right to left:\nwww.kbw.ch\n\nTLD: .ch (Switzerland)\n\nSecond-level domain: kbw\n\nSubdomain: www"
  },
  {
    "objectID": "files/lektionen_hs25/250820/tld.html#what-are-top-level-domains",
    "href": "files/lektionen_hs25/250820/tld.html#what-are-top-level-domains",
    "title": "4 Top-level domains and their allocation",
    "section": "",
    "text": "Top-level domains (TLDs) are the last part of a domain name – the part after the last dot. In the address www.example.com, ‘.com’ is the top-level domain. TLDs form the highest hierarchical level in the Domain Name System (DNS) and are essential for the organisation of the Internet.\nEvery domain name follows a hierarchical structure that is read from right to left:\nwww.kbw.ch\n\nTLD: .ch (Switzerland)\n\nSecond-level domain: kbw\n\nSubdomain: www"
  },
  {
    "objectID": "files/lektionen_hs25/250820/tld.html#types-of-top-level-domains",
    "href": "files/lektionen_hs25/250820/tld.html#types-of-top-level-domains",
    "title": "4 Top-level domains and their allocation",
    "section": "Types of top-level domains",
    "text": "Types of top-level domains\n\n1. Generic top-level domains (gTLDs)\nGeneric TLDs are not country-specific and can be registered worldwide:\n\n.com – Commercial (originally for companies)\n.org – Organisation (for organisations)\n.net – Network (originally for network providers)\n.edu – Education (only for accredited educational institutions)\n.gov – Government (only for US government agencies)\n.mil – Military (only for the US military)\n\n\n\n2. Country Code Top Level Domains (ccTLDs)\nEach country is assigned a two-letter code according to ISO 3166-1:\n\n.ch – Switzerland (Confoederatio Helvetica)\n.de – Germany\n.fr – France\n.uk – United Kingdom\n.us – United States\n\nThere are a total of 249 ccTLDs for countries and territories.\n\n\n3. New Generic Top Level Domains (ngTLDs)\nSince 2013, over 1,200 new TLDs have been introduced:\n\n.shop, .blog, .app\n.berlin, .paris, .swiss\n.google, .apple (brand TLDs)"
  },
  {
    "objectID": "files/lektionen_hs25/250820/tld.html#the-registry-icann-and-iana",
    "href": "files/lektionen_hs25/250820/tld.html#the-registry-icann-and-iana",
    "title": "4 Top-level domains and their allocation",
    "section": "The registry: ICANN and IANA",
    "text": "The registry: ICANN and IANA\nThe Internet Corporation for Assigned Names and Numbers (ICANN) is the central organisation for the administration of the domain name system. It was founded in 1998 and is headquartered in Los Angeles, USA.\nThe Internet Assigned Numbers Authority (IANA), a division of ICANN, manages the root zone of the DNS. This contains all TLDs and their associated name servers.\n\nHierarchy of allocation\n\nICANN/IANA → Manages all TLDs\nRegistry → Operates a specific TLD (e.g. SWITCH for .ch)\nRegistrar → Sells domains to end customers\nRegistrant → The domain owner"
  },
  {
    "objectID": "files/lektionen_hs25/250820/tld.html#the-allocation-process-for-new-gtlds",
    "href": "files/lektionen_hs25/250820/tld.html#the-allocation-process-for-new-gtlds",
    "title": "4 Top-level domains and their allocation",
    "section": "The allocation process for new gTLDs",
    "text": "The allocation process for new gTLDs\n\nPhase 1: Application\nOrganisations can apply to ICANN for new TLDs. The last major application round was in 2012:\n\nApplication fee: USD 185,000\nApplication period: 4 months\nApplications received: 1,930\n\n\n\nPhase 2: Evaluation\nICANN reviews each application for: - Technical competence - Financial stability - No trademark infringements - Public interest\n\n\nPhase 3: Delegation\nAfter successful review, the TLD is entered into the root zone. The entire process typically takes 18-24 months."
  },
  {
    "objectID": "files/lektionen_hs25/250820/tld.html#costs-and-fees",
    "href": "files/lektionen_hs25/250820/tld.html#costs-and-fees",
    "title": "4 Top-level domains and their allocation",
    "section": "Costs and fees",
    "text": "Costs and fees\n\nFor registry operators\n\nAnnual ICANN fee: USD 25,000 per TLD\nTransaction fee: USD 0.25 per domain registration\nOperating costs: Technical infrastructure, personnel, marketing\n\n\n\nFor end customers (examples)\n\n.ch domain: CHF 10-20 per year\n.com domain: CHF 15-25 per year\nPremium ngTLDs: CHF 50-500+ per year"
  },
  {
    "objectID": "files/lektionen_hs25/250820/tld.html#special-regulations",
    "href": "files/lektionen_hs25/250820/tld.html#special-regulations",
    "title": "4 Top-level domains and their allocation",
    "section": "Special regulations",
    "text": "Special regulations\n\nRestricted TLDs\nSome TLDs have special registration conditions:\n\n.edu – Only for accredited US universities\n.museum – Only for museums\n.aero – Only for the aviation industry\n.swiss – Connection to Switzerland required\n\n\n\nInternationalised domain names (IDN)\nSince 2010, TLDs in non-Latin scripts have been possible:\n\n.中国 (China)\n.рф (Russia)\n.ελ (Greece)"
  },
  {
    "objectID": "files/lektionen_hs25/250820/tld.html#statistical-overview",
    "href": "files/lektionen_hs25/250820/tld.html#statistical-overview",
    "title": "4 Top-level domains and their allocation",
    "section": "Statistical overview",
    "text": "Statistical overview\nAs of 2025, there are:\n\nActive TLDs: ~1,500\nRegistered domains worldwide: ~370 million\nLargest TLD: .com with ~160 million domains\nSwiss .ch domains: ~2.5 million\n\nThe distribution follows a power law: the 10 largest TLDs host around 75% of all domains."
  },
  {
    "objectID": "files/lektionen_hs25/250820/tld.html#significance-and-outlook",
    "href": "files/lektionen_hs25/250820/tld.html#significance-and-outlook",
    "title": "4 Top-level domains and their allocation",
    "section": "Significance and outlook",
    "text": "Significance and outlook\nTop-level domains are more than just technical designations – they are digital identities. A .ch domain signals Swiss origin, while a .edu domain stands for education. With the continuous expansion of the Internet, the importance of a well-thought-out TLD structure is also growing.\nThe next ICANN application round for new gTLDs is planned for 2026. Experts expect another 500-1,000 new TLDs, including an increasing number of city and brand names. The challenge will be to maintain a balance between innovation and clarity."
  },
  {
    "objectID": "files/lektionen_hs25/250903/sockets.html",
    "href": "files/lektionen_hs25/250903/sockets.html",
    "title": "6 Python Sockets: A Simple Client-Server Example",
    "section": "",
    "text": "In this section, we explore how to create a simple client-server application using Python sockets. This example will demonstrate the basic concepts of socket programming, including how to establish a connection and send and receive data."
  },
  {
    "objectID": "files/lektionen_hs25/250903/sockets.html#communication-structure",
    "href": "files/lektionen_hs25/250903/sockets.html#communication-structure",
    "title": "6 Python Sockets: A Simple Client-Server Example",
    "section": "Communication Structure",
    "text": "Communication Structure\nThe example will consist of a server that listens for incoming connections and a client that connects to the server. We will model the communication as a simple chat service."
  },
  {
    "objectID": "files/lektionen_hs25/250903/sockets.html#server-code",
    "href": "files/lektionen_hs25/250903/sockets.html#server-code",
    "title": "6 Python Sockets: A Simple Client-Server Example",
    "section": "Server Code",
    "text": "Server Code\nYou don’t need a virtual environment. The example uses only the Python standard library.\nBelow is the working code example for the socket server:\n# socket_server.py\n\nimport socket\n\ndef server_program():\n    # define host name and port\n    host = 'localhost'    # for communication on the local machine\n    port = 5000           # use a port number above 1024\n    \n    # create socket\n    server_socket = socket.socket()\n    \n    # bind the socket to the host and port\n    server_socket.bind((host, port))\n    \n    # set the server to listen for connections\n    server_socket.listen(2) # start listening \n                            # with a backlog of 2 \n                            # (max queued connections)\n    \n    # accept new connection from client\n    conn, address = server_socket.accept()\n    print(\"Connection from: \" + str(address))\n    \n    while True:\n        # receive up to 1024 bytes per call\n        data = conn.recv(1024).decode()\n        if not data:\n            # if no data is received, break\n            break\n        print(\"Received from connected client: \" + str(data))\n        # prompt the user to enter a message\n        data = input(' -&gt; ')\n        # send data to the client as bytes\n        conn.send(data.encode())\n        \n    # close the connection\n    conn.close()\n    \nif __name__ == '__main__':\n    server_program()\nTo run the script directly, open a terminal in the directory where the script is located and run the following command:\npython socket_server.py\nWhat happens when you do so is explained in the following sections.\nThe code consists of two main parts: the server_program function and the if __name__ == '__main__' block. The server_program function contains the main logic for the server, while the if block is used to execute the server code when the script is run directly.\nWhen you run the script, Python first imports the socket module.\n\nimport socket\n\nNext, the server_program function is called. Inside this function, the first thing that happens is the definition of the host address and the port number. localhost is a special address that refers to the local machine. localhost is equivalent to the IPv4 address 127.0.0.1. This means that the server will only accept connections from clients running on the same machine. This is a simulation of a network on the local machine.\n\ndef server_program():\n    # define host name and port\n    host = 'localhost'    # for communication on the local machine\n    port = 5000           # use a port number above 1024\n\nBelow, the server_socket is created using the socket.socket() function, which creates a new socket object.\n\nserver_socket = socket.socket()\n\nThis socket will be used to listen for incoming connections from clients. To make the connection work, the server_socket must be bound to the host and port using the bind().\n\nserver_socket.bind((host, port))\n\nNext, the server is set to listen for incoming connections with the listen() method.\n\nserver_socket.listen(2) # start listening \n                        # with a backlog of 2 \n                        # (max queued connections)\n\nThe server sets a backlog of 2 pending connections. The code, however, accepts exactly one client connection (accept() is called once). To handle multiple clients, call accept() in a loop and use threads or asyncio. This limit is set to prevent the server from being overwhelmed by too many connections at once. The accept() method is used to accept a new connection from a client. This method returns a tuple containing two items: conn, a new socket object for client communication, and address, the client’s address. The next chunk shows, how a message is printed to show the address of the connected client.\n\nconn, address = server_socket.accept()\nprint(\"Connection from: \" + str(address))\n\nThe while loop lets the server wait for data from the client. The recv() method is used to receive data from the client. Each recv() call reads up to 1024 bytes; additional data remains in the buffer and can be read by subsequent calls. If no data is received, the server breaks out of the loop and closes the connection.\n\nwhile True:\n        # receive up to 1024 bytes per call\n        data = conn.recv(1024).decode()\n        if not data:\n            # if no data is received, break\n            break\n\nIf the server receives data, it prints the data to the console and then prompts the user to enter a response. The response is sent back to the client using the send() method.\n\nprint(\"Received from connected client: \" + str(data))\n        # prompt the user to enter a message\n        data = input(' -&gt; ')\n        # send data to the client as bytes\n        conn.send(data.encode())"
  },
  {
    "objectID": "files/lektionen_hs25/250903/sockets.html#client-code",
    "href": "files/lektionen_hs25/250903/sockets.html#client-code",
    "title": "6 Python Sockets: A Simple Client-Server Example",
    "section": "Client Code",
    "text": "Client Code\nBelow is the working code of the  client example:\n# socket_client.py\n\nimport socket\n\ndef client_program():\n    # define host name and port (of the server to connect to)\n    host = 'localhost'  # as both pieces of code are \n                        # running on the same machine\n    port = 5000         # socket server port number\n    \n    # create socket\n    client_socket = socket.socket()\n    \n    # connect to the server\n    client_socket.connect((host, port))\n    \n    # prompt the user to enter a message\n    message = input(\" -&gt; \")  # take input\n    \n    # message loop\n    while message.lower().strip() != 'bye':\n        # send message to the server as bytes\n        client_socket.send(message.encode())\n        \n        # receive response from the server\n        data = client_socket.recv(1024).decode()\n        \n        print('Received from server: ' + data)\n        \n        # prompt the user to enter a new message\n        message = input(\" -&gt; \")  # take new input\n        \n    # close the connection\n    client_socket.close()\n    \nif __name__ == '__main__':\n    client_program()\nTo run this script, follow the same steps as for the server script. Open a terminal in the directory where the script is located and run the following command:\npython socket_client.py\nStart the server before the client. If the server is not running, client_socket.connect(…) will raise a ConnectionRefusedError.\nWhen you run the script, Python first imports the socket module.\nNext, the client_program function is called. Inside this function, the first thing that happens is the definition of the host address and the port number. Here, the host address and the port number have to be the ones defined in the server script.\nAfter defining the host and port, the client creates a socket object using the socket.socket() function. This socket will be used to connect to the server. The connect() method is called on the socket object to establish a connection to the server.\nOnce the connection is established, the client enters a loop where it can send messages to the server and receive responses. The client prompts the user to enter a message, which is then sent to the server using the send() method. The client also waits for a response from the server using the recv() method.\nIf the user enters bye, the client will exit the loop and close the connection to the server."
  },
  {
    "objectID": "files/lektionen_hs25/250903/sockets.html#conclusion",
    "href": "files/lektionen_hs25/250903/sockets.html#conclusion",
    "title": "6 Python Sockets: A Simple Client-Server Example",
    "section": "Conclusion",
    "text": "Conclusion\nThe presented code examples illustrate how Python’s built-in socket module (standard library) enables straightforward implementation of networked applications without requiring external dependencies. The tutorial’s focus on localhost communication provides a safe, controlled environment for experimentation and learning, while the bidirectional message exchange demonstrates real-world communication patterns found in production systems.\nKey achievements of this implementation include:\n\nSuccessful establishment of TCP socket connections between separate processes\nImplementation of message-based communication with proper encoding/decoding\nDemonstration of connection lifecycle management from establishment to termination\nCreation of a simple command-line interface for both server and client applications\n\nThe knowledge gained from this tutorial serves as a solid foundation for developing more sophisticated networked applications. Future enhancements could include implementing multithreading for concurrent client handling, adding error handling and reconnection logic, or expanding the communication protocol to support structured data formats."
  },
  {
    "objectID": "files/lektionen_hs25/250910_file_handling/files.html",
    "href": "files/lektionen_hs25/250910_file_handling/files.html",
    "title": "7 File Handling",
    "section": "",
    "text": "To edit text files in Python, we write a function that assigns the content of a file to a variable as a string.\n\ndef file_reader(path : str) -&gt; str:\n\n    with open(path, mode='r', encoding='utf-8') as f:\n        text = f.read()\n\n    return text\n\nTo write encrypted or decrypted text to a file in Python, we write a function that writes a string to a file.\n\ndef file_writer(path : str, text : str) -&gt; None:\n    i = 0\n    grouped_text = \"\"\n    for c in text:\n        i += 1\n        if i % 50 == 0:\n            grouped_text += c + \"\\n\"\n        elif i % 5 == 0:\n            grouped_text += c + \" \"\n        else:\n            grouped_text += c\n        \n    with open(path, mode='w', encoding='utf-8') as f:\n        f.write(grouped_text)\n\nTo ensure that texts consist exclusively of ASCII uppercase letters, we write a function that converts all lowercase letters to uppercase and converts all umlauts to their equivalent letters. All other characters are removed.\nTo have all methods for processing strings available, the string module must first be imported.\n\nimport string\n\n\ndef text_cleaning(text : str) -&gt; str:\n    clean = text.upper() \\\n                .replace('Ä', 'AE') \\\n                .replace('Ö', 'OE') \\\n                .replace('Ü', 'UE') \\\n                .replace('ß', 'SS') \\\n                .replace(' ', '') \\\n\n    cleaned_text = ''\n\n    for c in clean:\n        if c.isalpha():\n            cleaned_text += c\n    \n    return cleaned_text"
  },
  {
    "objectID": "files/materialien/240904/schweizerfahne.html",
    "href": "files/materialien/240904/schweizerfahne.html",
    "title": "Einfache Zeichnungen mit PyTamaro",
    "section": "",
    "text": "Hier geht es zur online Anleitung für PyTamaro.\nAls Beispiel für die Vorgehnsweise wird hier die Französische Trikolore gezeichnet. Das Seitenverhältnis der Trikolore ist 2 zu 3.\n# Import der erforderlichen Libraries (nur einmal pro Notebook nötig)\nfrom pytamaro.de import (\n    rot, blau, weiss,\n    rechteck, kreis_sektor, ellipse,\n    drehe, neben, ueber,\n    zeige_grafik\n)\nAls erstes werden die einzelnen Rechtecke gezeichnet.\nbleu = rechteck(10, 20, blau)\nzeige_grafik(bleu)\nblanc = rechteck(10, 20, weiss)\nzeige_grafik(blanc)\nrouge = rechteck(10, 20, rot)\nzeige_grafik(rouge)\nAnschliessend werden die Einzelteile zusammengesetzt.\nzweidrittel = neben(bleu, blanc)\nzeige_grafik(zweidrittel)\ntrikolore = neben(zweidrittel, rouge)\nzeige_grafik(trikolore)"
  },
  {
    "objectID": "files/materialien/240904/schweizerfahne.html#tessiner-wappen",
    "href": "files/materialien/240904/schweizerfahne.html#tessiner-wappen",
    "title": "Einfache Zeichnungen mit PyTamaro",
    "section": "Tessiner Wappen",
    "text": "Tessiner Wappen\nPyTamaro wird von einem Team an der Università della Svizzera italiana in Lugano entwickelt. Zu ehren des Standortkantons geht es in einer ersten Übung darum, das Tessiner Wappen zu zeichnen.\n\n\nVorgehen\n\nDas Wappen wird in Einzelteile zerlegt.\n\nDie Einzelteile werden aufgelistet.\n\nrotes Rechteck\nblaues Rechteck\nroter Viertelkreis\nblauer Viertelkreis\n\nDie Einzelteile werden mit PyTamaro programmiert.\nDie Einzelteile werden mit PyTamaro zusammengesetzt.\n\n\n\nUmsetzung in PyTamaro\n\n# Hier das rote Rechteck zeichnen\n\n\n# Hier das blaue Rechteck zeichnen\n\n\n# Hier den roten Viertelkreis zeichnen\n\n\n# Hier den blauen Viertelkreis zeichnen\n\n\n# hier die obere Hälfte zusammensetzen\n\n\n# hier die untere Hälfte zusammensetzen\n\n\n# hir das ganze Wappen zusammensetzen\n\n\n\nCode Aufräumen (Refactoring)\nDie Erste Aufgabe beim Programmieren ist sicher die Lösung des konkreten Problems. Eng damit Verbunden ist allerdings auch die übersichtliche Darstellung des Programms. Dabei ist insbesondere darauf zu achten, das Wiederholungen so weit wie möglich vermieden werden. Unten steht der bereinigte Code der verwendet wurde, um das Tessiner Wappen zu zeichnen.\nrotes_rechteck = rechteck(10, 15, rot)\nblaues_rechteck = rechteck(10, 15, blau)\nroter_viertelkreis = kreis_sektor(10, 90, rot)\nroter_viertelkreis = drehe(180, roter_viertelkreis)\nblauer_viertelkreis = kreis_sektor(10, 90, blau)\nblauer_viertelkreis = drehe(270, blauer_viertelkreis)\nobere_haelfte = neben(rotes_rechteck, blaues_rechteck)\nuntere_haelfte = neben(roter_viertelkreis, blauer_viertelkreis)\nti = ueber(obere_haelfte, untere_haelfte)\nzeige_grafik(ti)\nDieser Code soll nun so bereinigt werden, dass Wiederholungen vermieden werden. Dabei soll allerdings dessen Verständlichkeit nicht leiden.\n\n# hier kommt der \"aufgeräumte Code\""
  },
  {
    "objectID": "files/materialien/240904/schweizerfahne.html#schweizerfahne",
    "href": "files/materialien/240904/schweizerfahne.html#schweizerfahne",
    "title": "Einfache Zeichnungen mit PyTamaro",
    "section": "Schweizerfahne",
    "text": "Schweizerfahne\nAlle kennen die Schweizerfahne. Ein weisses Kreuz auf rotem Grund. Was viele nicht wissen, dass es für die genauen Proportionen eine gesetzliche Grundlage gibt, das Bundesgesetz über den Schutz des Schweizerwappens und anderer öffentlicher Zeichen (Wappenschutzgesetz, WSchG). Das WSchG regelt in seinem Anhang 2 die Proportionen und die Farben der Schweizerfahne.\n\nBasierend auf diesen Vorgaben soll die Schweizerfahne gezeichnet werden.\n\nUmsetzung in PyTamaro\n\nfrom pytamaro.de import (\n    ueberlagere,\n    rgb_farbe\n)\n\n\n# hier kommt der Code für die Schweizerfahne"
  },
  {
    "objectID": "files/materialien/240925/conditions.html",
    "href": "files/materialien/240925/conditions.html",
    "title": "Bedingungen in Python",
    "section": "",
    "text": "from pytamaro.de import (\n    gelb, schwarz,\n    rechteck,\n    neben, ueber,\n    zeige_grafik,\n)\n\n\ngelbes = rechteck(20, 20, gelb)\nschwarzes = rechteck(20, 20, schwarz)\n\n\nungerade_reihe = gelbes\n\nfor i in range(2, 9):\n    if i % 2 == 0:\n        ungerade_reihe = neben(ungerade_reihe, schwarzes)\n        print(i)\n    else:\n        ungerade_reihe = neben(ungerade_reihe, gelbes)\n\nzeige_grafik(ungerade_reihe)\n\n2\n4\n6\n8"
  },
  {
    "objectID": "files/lektionen_hs25/250924_break_vienere/break.html",
    "href": "files/lektionen_hs25/250924_break_vienere/break.html",
    "title": "11 Breaking the Vigenère Cipher",
    "section": "",
    "text": "The crucial weakness of the Vigenère cipher was discovered independently by two men in the midst of the 19th century. One of them was Charles Babbage, a British polymath. He discovered the weakness in order to win a bet. The other was Friedrich Wilhelm Kasiski, who was a retired Major of the Prussian army. Who, after retirement, spent his time writing.\nThe method of breaking the Vigenère cipher is named after Prussian Major Kasiski."
  },
  {
    "objectID": "files/lektionen_hs25/250924_break_vienere/break.html#the-kasiski-method---summary",
    "href": "files/lektionen_hs25/250924_break_vienere/break.html#the-kasiski-method---summary",
    "title": "11 Breaking the Vigenère Cipher",
    "section": "The Kasiski Method - Summary",
    "text": "The Kasiski Method - Summary\nThe Kasiski method is a technique for breaking the Vigenère cipher by exploiting repeated patterns in the ciphertext. Here’s how it works:\n\nKey Principle\nWhen the same plaintext sequence is encrypted with the same portion of the key, it produces identical ciphertext sequences. By finding these repetitions, we can determine the key length.\n\n\nStep-by-Step Process\n\nFind Repeated Sequences\n\nScan the ciphertext for identical sequences of 3+ characters\nRecord the positions where these sequences occur\n\nCalculate Distances\n\nMeasure the distance between repeated sequences\nThe key length must be a divisor of these distances\n\nDetermine Key Length\n\nFind the Greatest Common Divisor (GCD) of all distances\nOr look for the most frequent common factor\nThis gives you the probable key length\n\nFrequency Analysis\n\nDivide the ciphertext into groups based on the key length\nEach group was encrypted with the same key character\nApply frequency analysis to each group separately\nMatch letter frequencies to expected language patterns\n\n\n\n\nExample\nIf “THE” appears multiple times in plaintext at positions where the key repeats, the corresponding ciphertext sequences will be identical. If these sequences are 10 positions apart, the key length is likely a divisor of 10 (1, 2, 5 or 10).\nFor a contrived example, if the plaintext is “the codes in the word and the message”, and the key is “crypt”, then we’d get the following ciphertext.\np: t h e c o d e s i n t h e w o r d a n d t h e m\nk: c r y p t c r y p t c r y p t c r y p t c r y p\nc: V Y C r h f v q x g V Y C l h t u y c w V Y C b\nNote that the ciphertext pattern VYC occurs three times in the ciphertext, and each time there is a distance of 10 letters between the beginning of one VYC and the next. This happens because the same pattern of plaintext, “the”, lines up with the same part of the key, “cry”, each time, resulting in the same ciphertext. The repetition of the keyword is the liability here. The ciphertext duplicates are all 10 letters apart. Babbage and Kasiski reasoned that this implies the length of the key is a factor of 10. The factors of 10 are 10, 5, and 2. One could argue that a key of length 2 is too short to provide much security, so that a key of length 5 or 10 is more reasonable. A key of length 10 is unlikely to have as many repetitions in such a short piece of ciphertext, so a key of length 5 is where the cryptanalyst will begin their work.\nA key of length 5 means that the 1st, 6th, 11th, 16th, etc., letters are all enciphered using the same key letter and hence the same alphabet from the Vigenère table. Similarly, the 2nd, 7th, 12th, 17th, etc. letters are all enciphered with the next key alphabet. So if we break up the cryptogram into 5 groups of letters we then have 5 monoalphabetic substitution ciphertexts. We can then do a frequency analysis of each group and solve each group separately. And in a standard shifted alphabet as in the normal Vigenère table, if we can find a single cipher alphabet letter we then have the entire alphabet.1\n\n\nWhy It Works\nThe Vigenère cipher’s weakness lies in key repetition. Once the key length is known, the cipher becomes multiple simple Caesar ciphers that can be broken using frequency analysis."
  },
  {
    "objectID": "files/lektionen_hs25/250924_break_vienere/break.html#footnotes",
    "href": "files/lektionen_hs25/250924_break_vienere/break.html#footnotes",
    "title": "11 Breaking the Vigenère Cipher",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nDooley, John F. History of Cryptography and Cryptanalysis: Codes, Ciphers, and Their Algorithms. History of Computing. Cham: Springer International Publishing, 2024. https://doi.org/10.1007/978-3-031-67485-3. p. 76.↩︎"
  },
  {
    "objectID": "files/lektionen_hs25/250918_vigenere_python/python_implementation.html",
    "href": "files/lektionen_hs25/250918_vigenere_python/python_implementation.html",
    "title": "10 Vigenère Cipher Implementation in Python",
    "section": "",
    "text": "This notebook presents a possible implementation of the Vigenère cipher in Python.\n\ndef vigenere(text: str, key: str, mode: str) -&gt; str:\n    \"\"\"Encrypts or decrypts a given text using the Vigenère cipher.\n\n    The function processes a string of uppercase alphabetic characters\n    using a provided key for encryption or decryption.\n\n    Args:\n        text: The string to be encrypted or decrypted. It should only contain\n              uppercase alphabetic characters (A-Z).\n        key: The key for the cipher. It should also only contain\n             uppercase alphabetic characters (A-Z).\n        mode: The operation to perform, must be 'encrypt' or 'decrypt'.\n\n    Returns:\n        The resulting ciphertext or plaintext.\n\n    Raises:\n        ValueError: If the mode is not 'encrypt' or 'decrypt'.\n    \"\"\"\n\n    # Ensure the mode is valid before proceeding.\n    if mode not in ['encrypt', 'decrypt']:\n        raise ValueError(\"Mode must be 'encrypt' or 'decrypt'\")\n    \n    key_length = len(key)\n    \n    if mode == 'encrypt':\n       cipher = ''\n       # Iterate through each character of the input text.\n       for i, char in enumerate(text):\n           # Convert the current text character and the corresponding key \n           # character to a number (0-25).\n           # The key character is determined using modulo to cycle through \n           # the key.\n           char_num = ord(char) - ord('A')\n           key_num = ord(key[i % key_length]) - ord('A')\n           \n           # Calculate the new character's number using the Vigenère encryption formula.\n           # The modulo operator ensures the result stays within the range 0-25.\n           cipher_num = (char_num + key_num) % 26\n           \n           # Convert the resulting number back to an uppercase character and append it.\n           cipher += chr(cipher_num + ord('A'))\n       return cipher  \n    else:  # mode == 'decrypt'\n        plain = ''\n        # Iterate through each character of the input text.\n        for i, char in enumerate(text):\n            # Convert the current text character and the corresponding key \n            # character to a number (0-25).\n            char_num = ord(char) - ord('A')\n            key_num = ord(key[i % key_length]) - ord('A')\n            \n            # Calculate the new character's number using the Vigenère \n            # decryption formula.\n            # The modulo operator handles negative results, ensuring the \n            # result is correct.\n            plain_num = (char_num - key_num) % 26\n            \n            # Convert the resulting number back to an uppercase \n            # character and append it.\n            plain += chr(plain_num + ord('A'))\n        return plain\n\nThe vigenere() function is explained in detail below.\nThe function signature\ndef vigenere(text: str, key: str, mode: str) -&gt; str:\nshows that the function expects three parameters: * text: The string to be encrypted or decrypted. * key: The key for encryption or decryption as a string. * mode: The mode that specifies whether the text should be encrypted or decrypted. Possible values are 'encrypt' for encryption and 'decrypt' for decryption (although this is not directly apparent from the signature).\nFollowing the signature is a detailed docstring that describes the function and its parameters. Although written in English, it is self-explanatory.\nThe docstring is followed by a check to see if valid values were passed for the mode parameter. If not, a ValueError exception is raised.\nif mode not in ['encrypt', 'decrypt']:\n    raise ValueError(\"Mode must be 'encrypt' or 'decrypt'\")\nTo perform this check, the allowed values are provided in a list. It then checks if the value assigned to mode is contained in the list. If this is not the case, an error message is displayed and the function’s execution is terminated.\nIf the mode parameter contains a valid value, the actual function logic comes into play.\nFirst, the length of the key is assigned to the variable key_length in\nkey_length = len(key)\nThis information will be needed later to iterate over the key’s text in a special type of loop.\nAfter this assignment, the function splits into the encryption and decryption branches.\nFirst, the encryption - initiated with if mode == 'encrypt': - is considered.\nInside this block, an empty string cipher is first initialized, which will later hold the encrypted characters.\nThen, a for loop is used to iterate over the text to be encrypted.\nfor i, char in enumerate(text):\nIn this loop, the enumerate() function is used. This function returns a tuple consisting of the index and the respective element of the structure being iterated over. The values of the tuple are assigned to the variables i and char.\nThe variables i and char are used inside the loop to convert the individual characters of the text into a number.\n    char_num = ord(char) - ord('A')\n    key_num = ord(key[i % key_length]) - ord('A')\nThe ord() function converts a letter into the corresponding number from the ASCII table. To ensure the numbers are in the range of 0 to 25, the ASCII value of the letter ‘A’ is subtracted. The letter ‘A’ is used because the characters to be encrypted are specified in uppercase.\nSince the key can be shorter than the text to be encrypted, i % key_length is used to iterate over the key. The modulo operator % ensures that the index value of the used index always stays between 0 and the length of the key key_length. This ensures that the key is started again from the beginning once the end of the key is reached. The individual letters of the key are then processed in the same way as the letters of the text.\nAfter the letters of the text and the key have been converted into numbers, the actual encryption is performed according to the formula \\(C_i = (P_i + K_i)\\ mod\\ 26\\).\n    cipher_num = (char_num + key_num) % 26\nThe numerical values of the encrypted text are then converted back into letters and appended to the string cipher. For this, the chr() function is used, which converts a number into the corresponding letter of the ASCII table. Since the numerical values are in the range of 0 to 25, the ASCII value of the letter ‘A’ is added.\n    cipher += chr(cipher_num + ord('A'))\nThe string stored under cipher is returned at the end of the block.\nIn the second block, the decryption - initiated with else: - is performed. The process is very similar to that of encryption, however, the inverse formula (\\(P_i = (C_i - K_i + 26)\\ mod\\ 26\\)) is used here.\n    plain_num = (char_num - key_num + 26) % 26\n    plain += chr(plain_num + ord('A'))\nEverything else corresponds to the procedure for encryption."
  }
]