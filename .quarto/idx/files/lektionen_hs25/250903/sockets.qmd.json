{"title":"6 Python Sockets: A Simple Client-Server Example","markdown":{"yaml":{"title":"6 Python Sockets: A Simple Client-Server Example","date":"2025-09-03","date-format":"DD.MM.YYYY","author":"Jacques Mock Schindler"},"headingText":"Communication Structure","containsRefs":false,"markdown":"\n\nIn this section, we explore how to create a simple client-server\napplication using Python sockets. This example will demonstrate the \nbasic concepts of socket programming, including how to establish a\nconnection and send and receive data.\n\n:::{.callout-note title=\"Network Socket\" appearance=\"simple\"}\nA network socket is an endpoint within a host used to send and receive\ndata over a network. \n:::\n\n\nThe example will consist of a server that listens for incoming\nconnections and a client that connects to the server. We will model the\ncommunication as a simple chat service. \n\n## Server Code\n\nYou don't need a virtual environment. The example uses only the Python\nstandard library.   \nBelow is the working code example for the\n<a\nhref=\"https://github.com/SkriptenMk/I_eW_24-28/blob/main/files/lektionen_hs25/250903/socket_server.py\"\ndownload=\"socket_server.py\" target=\"_blank\">socket server</a>:\n\n```python\n# socket_server.py\n\nimport socket\n\ndef server_program():\n    # define host name and port\n    host = 'localhost'    # for communication on the local machine\n    port = 5000           # use a port number above 1024\n    \n    # create socket\n    server_socket = socket.socket()\n    \n    # bind the socket to the host and port\n    server_socket.bind((host, port))\n    \n    # set the server to listen for connections\n    server_socket.listen(2) # start listening \n                            # with a backlog of 2 \n                            # (max queued connections)\n    \n    # accept new connection from client\n    conn, address = server_socket.accept()\n    print(\"Connection from: \" + str(address))\n    \n    while True:\n        # receive up to 1024 bytes per call\n        data = conn.recv(1024).decode()\n        if not data:\n            # if no data is received, break\n            break\n        print(\"Received from connected client: \" + str(data))\n        # prompt the user to enter a message\n        data = input(' -> ')\n        # send data to the client as bytes\n        conn.send(data.encode())\n        \n    # close the connection\n    conn.close()\n    \nif __name__ == '__main__':\n    server_program()\n```\n\nTo run the script directly, open a terminal in the directory where the\nscript is located and run the following command: \n\n```{bash}\npython socket_server.py\n```\n\nWhat happens when you do so is explained in the following sections.\n\nThe code consists of two main parts: the `server_program` function and\nthe `if __name__ == '__main__'` block. The `server_program` function\ncontains the main logic for the server, while the `if` block is used to\nexecute the server code when the script is run directly.\n\nWhen you run the script, Python first imports the `socket` module.\n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nimport socket\n```\n\nNext, the `server_program` function is called. Inside this function, the\nfirst thing that happens is the definition of the host address and the\nport number. `localhost` is a special address that refers to the local\nmachine. `localhost` is equivalent to the IPv4 address `127.0.0.1`.\nThis means that the server will only accept connections from\nclients running on the same machine. This is a simulation of a network\non the local machine.  \n\n```{python}\n#| code-line-numbers: false\n#| eval: false\ndef server_program():\n    # define host name and port\n    host = 'localhost'    # for communication on the local machine\n    port = 5000           # use a port number above 1024\n```\n\nBelow, the `server_socket` is created using the `socket.socket()`\nfunction, which creates a new socket object. \n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nserver_socket = socket.socket()\n```\n\nThis socket will be used\nto listen for incoming connections from clients. To make the connection\nwork, the `server_socket` must be bound to the host and port using the\n`bind()`.\n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nserver_socket.bind((host, port))\n```\n\nNext, the server is set to listen for\nincoming connections with the `listen()` method.\n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nserver_socket.listen(2) # start listening \n                        # with a backlog of 2 \n                        # (max queued connections)\n```\n\nThe server\nsets a backlog of 2 pending connections. The code, however, accepts\nexactly one client connection (accept() is called once). To handle\nmultiple clients, call accept() in a loop and use threads or asyncio.\nThis limit is set to prevent the server from being overwhelmed by too\nmany connections at once. The `accept()` method is used to accept a new\nconnection from a client. This method returns a tuple containing two\nitems: conn, a new socket object for client communication, and address,\nthe client's address. The next chunk shows, how a message is printed to show the\naddress of the\nconnected client.   \n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nconn, address = server_socket.accept()\nprint(\"Connection from: \" + str(address))\n```\n\nThe while loop lets the server wait for data from the\nclient. The `recv()` method is used to receive data from the client.\nEach `recv()` call reads up to 1024 bytes; additional data remains in the\nbuffer and can be read by subsequent calls. If no data is\nreceived, the server breaks out of the loop and closes the connection.\n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nwhile True:\n        # receive up to 1024 bytes per call\n        data = conn.recv(1024).decode()\n        if not data:\n            # if no data is received, break\n            break\n        \n```\n\nIf the server receives data, it prints the data to the console and then\nprompts the user to enter a response. The response is sent\nback to the client using the `send()` method.\n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nprint(\"Received from connected client: \" + str(data))\n        # prompt the user to enter a message\n        data = input(' -> ')\n        # send data to the client as bytes\n        conn.send(data.encode())\n```\n\n## Client Code\n\nBelow is the working code of the\n<a href=\"https://github.com/SkriptenMk/I_eW_24-28/blob/main/files/lektionen_hs25/250903/socket_client.py\">\nclient example</a>:\n\n```python\n# socket_client.py\n\nimport socket\n\ndef client_program():\n    # define host name and port (of the server to connect to)\n    host = 'localhost'  # as both pieces of code are \n                        # running on the same machine\n    port = 5000         # socket server port number\n    \n    # create socket\n    client_socket = socket.socket()\n    \n    # connect to the server\n    client_socket.connect((host, port))\n    \n    # prompt the user to enter a message\n    message = input(\" -> \")  # take input\n    \n    # message loop\n    while message.lower().strip() != 'bye':\n        # send message to the server as bytes\n        client_socket.send(message.encode())\n        \n        # receive response from the server\n        data = client_socket.recv(1024).decode()\n        \n        print('Received from server: ' + data)\n        \n        # prompt the user to enter a new message\n        message = input(\" -> \")  # take new input\n        \n    # close the connection\n    client_socket.close()\n    \nif __name__ == '__main__':\n    client_program()\n```\n\nTo run this script, follow the same steps as for the server script.\nOpen a terminal in the directory where the script is located and run the\nfollowing command: \n\n```bash\npython socket_client.py\n```\n\nStart the server before the client. If the server is not running,\nclient_socket.connect(...) will raise a ConnectionRefusedError. \n\nWhen you run the script, Python first imports the `socket` module.\n\nNext, the `client_program` function is called. Inside this function, the\nfirst thing that happens is the definition of the host address and the\nport number. Here, the host address and the port number have to be the\nones defined in the server script.\n\nAfter defining the host and port, the client creates a socket object\nusing the `socket.socket()` function. This socket will be used to\nconnect to the server. The `connect()` method is called on the socket\nobject to establish a connection to the server.\n\nOnce the connection is established, the client enters a loop where it\ncan send messages to the server and receive responses. The client\nprompts the user to enter a message, which is then sent to the server\nusing the `send()` method. The client also waits for a response from\nthe server using the `recv()` method.\n\nIf the user enters `bye`, the client will exit the loop and close the\nconnection to the server.\n\n\n## Conclusion\n\nThe presented code examples illustrate how Python's built-in socket\nmodule (standard library) enables straightforward implementation of\nnetworked applications without requiring external dependencies. The\ntutorial's focus on localhost communication provides a safe, controlled\nenvironment for experimentation and learning, while the bidirectional\nmessage exchange demonstrates real-world communication patterns found\nin production systems.\n\nKey achievements of this implementation include:\n\n* Successful establishment of TCP socket connections between separate\n  processes\n* Implementation of message-based communication with proper\n  encoding/decoding\n* Demonstration of connection lifecycle management from establishment to\n  termination\n* Creation of a simple command-line interface for both server and client\n  applications\n\nThe knowledge gained from this tutorial serves as a solid foundation for\ndeveloping more sophisticated networked applications. Future\nenhancements could include implementing multithreading for concurrent\nclient handling, adding error handling and reconnection logic, or\nexpanding the communication protocol to support structured data formats. \n","srcMarkdownNoYaml":"\n\nIn this section, we explore how to create a simple client-server\napplication using Python sockets. This example will demonstrate the \nbasic concepts of socket programming, including how to establish a\nconnection and send and receive data.\n\n:::{.callout-note title=\"Network Socket\" appearance=\"simple\"}\nA network socket is an endpoint within a host used to send and receive\ndata over a network. \n:::\n\n## Communication Structure\n\nThe example will consist of a server that listens for incoming\nconnections and a client that connects to the server. We will model the\ncommunication as a simple chat service. \n\n## Server Code\n\nYou don't need a virtual environment. The example uses only the Python\nstandard library.   \nBelow is the working code example for the\n<a\nhref=\"https://github.com/SkriptenMk/I_eW_24-28/blob/main/files/lektionen_hs25/250903/socket_server.py\"\ndownload=\"socket_server.py\" target=\"_blank\">socket server</a>:\n\n```python\n# socket_server.py\n\nimport socket\n\ndef server_program():\n    # define host name and port\n    host = 'localhost'    # for communication on the local machine\n    port = 5000           # use a port number above 1024\n    \n    # create socket\n    server_socket = socket.socket()\n    \n    # bind the socket to the host and port\n    server_socket.bind((host, port))\n    \n    # set the server to listen for connections\n    server_socket.listen(2) # start listening \n                            # with a backlog of 2 \n                            # (max queued connections)\n    \n    # accept new connection from client\n    conn, address = server_socket.accept()\n    print(\"Connection from: \" + str(address))\n    \n    while True:\n        # receive up to 1024 bytes per call\n        data = conn.recv(1024).decode()\n        if not data:\n            # if no data is received, break\n            break\n        print(\"Received from connected client: \" + str(data))\n        # prompt the user to enter a message\n        data = input(' -> ')\n        # send data to the client as bytes\n        conn.send(data.encode())\n        \n    # close the connection\n    conn.close()\n    \nif __name__ == '__main__':\n    server_program()\n```\n\nTo run the script directly, open a terminal in the directory where the\nscript is located and run the following command: \n\n```{bash}\npython socket_server.py\n```\n\nWhat happens when you do so is explained in the following sections.\n\nThe code consists of two main parts: the `server_program` function and\nthe `if __name__ == '__main__'` block. The `server_program` function\ncontains the main logic for the server, while the `if` block is used to\nexecute the server code when the script is run directly.\n\nWhen you run the script, Python first imports the `socket` module.\n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nimport socket\n```\n\nNext, the `server_program` function is called. Inside this function, the\nfirst thing that happens is the definition of the host address and the\nport number. `localhost` is a special address that refers to the local\nmachine. `localhost` is equivalent to the IPv4 address `127.0.0.1`.\nThis means that the server will only accept connections from\nclients running on the same machine. This is a simulation of a network\non the local machine.  \n\n```{python}\n#| code-line-numbers: false\n#| eval: false\ndef server_program():\n    # define host name and port\n    host = 'localhost'    # for communication on the local machine\n    port = 5000           # use a port number above 1024\n```\n\nBelow, the `server_socket` is created using the `socket.socket()`\nfunction, which creates a new socket object. \n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nserver_socket = socket.socket()\n```\n\nThis socket will be used\nto listen for incoming connections from clients. To make the connection\nwork, the `server_socket` must be bound to the host and port using the\n`bind()`.\n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nserver_socket.bind((host, port))\n```\n\nNext, the server is set to listen for\nincoming connections with the `listen()` method.\n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nserver_socket.listen(2) # start listening \n                        # with a backlog of 2 \n                        # (max queued connections)\n```\n\nThe server\nsets a backlog of 2 pending connections. The code, however, accepts\nexactly one client connection (accept() is called once). To handle\nmultiple clients, call accept() in a loop and use threads or asyncio.\nThis limit is set to prevent the server from being overwhelmed by too\nmany connections at once. The `accept()` method is used to accept a new\nconnection from a client. This method returns a tuple containing two\nitems: conn, a new socket object for client communication, and address,\nthe client's address. The next chunk shows, how a message is printed to show the\naddress of the\nconnected client.   \n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nconn, address = server_socket.accept()\nprint(\"Connection from: \" + str(address))\n```\n\nThe while loop lets the server wait for data from the\nclient. The `recv()` method is used to receive data from the client.\nEach `recv()` call reads up to 1024 bytes; additional data remains in the\nbuffer and can be read by subsequent calls. If no data is\nreceived, the server breaks out of the loop and closes the connection.\n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nwhile True:\n        # receive up to 1024 bytes per call\n        data = conn.recv(1024).decode()\n        if not data:\n            # if no data is received, break\n            break\n        \n```\n\nIf the server receives data, it prints the data to the console and then\nprompts the user to enter a response. The response is sent\nback to the client using the `send()` method.\n\n```{python}\n#| code-line-numbers: false\n#| eval: false\nprint(\"Received from connected client: \" + str(data))\n        # prompt the user to enter a message\n        data = input(' -> ')\n        # send data to the client as bytes\n        conn.send(data.encode())\n```\n\n## Client Code\n\nBelow is the working code of the\n<a href=\"https://github.com/SkriptenMk/I_eW_24-28/blob/main/files/lektionen_hs25/250903/socket_client.py\">\nclient example</a>:\n\n```python\n# socket_client.py\n\nimport socket\n\ndef client_program():\n    # define host name and port (of the server to connect to)\n    host = 'localhost'  # as both pieces of code are \n                        # running on the same machine\n    port = 5000         # socket server port number\n    \n    # create socket\n    client_socket = socket.socket()\n    \n    # connect to the server\n    client_socket.connect((host, port))\n    \n    # prompt the user to enter a message\n    message = input(\" -> \")  # take input\n    \n    # message loop\n    while message.lower().strip() != 'bye':\n        # send message to the server as bytes\n        client_socket.send(message.encode())\n        \n        # receive response from the server\n        data = client_socket.recv(1024).decode()\n        \n        print('Received from server: ' + data)\n        \n        # prompt the user to enter a new message\n        message = input(\" -> \")  # take new input\n        \n    # close the connection\n    client_socket.close()\n    \nif __name__ == '__main__':\n    client_program()\n```\n\nTo run this script, follow the same steps as for the server script.\nOpen a terminal in the directory where the script is located and run the\nfollowing command: \n\n```bash\npython socket_client.py\n```\n\nStart the server before the client. If the server is not running,\nclient_socket.connect(...) will raise a ConnectionRefusedError. \n\nWhen you run the script, Python first imports the `socket` module.\n\nNext, the `client_program` function is called. Inside this function, the\nfirst thing that happens is the definition of the host address and the\nport number. Here, the host address and the port number have to be the\nones defined in the server script.\n\nAfter defining the host and port, the client creates a socket object\nusing the `socket.socket()` function. This socket will be used to\nconnect to the server. The `connect()` method is called on the socket\nobject to establish a connection to the server.\n\nOnce the connection is established, the client enters a loop where it\ncan send messages to the server and receive responses. The client\nprompts the user to enter a message, which is then sent to the server\nusing the `send()` method. The client also waits for a response from\nthe server using the `recv()` method.\n\nIf the user enters `bye`, the client will exit the loop and close the\nconnection to the server.\n\n\n## Conclusion\n\nThe presented code examples illustrate how Python's built-in socket\nmodule (standard library) enables straightforward implementation of\nnetworked applications without requiring external dependencies. The\ntutorial's focus on localhost communication provides a safe, controlled\nenvironment for experimentation and learning, while the bidirectional\nmessage exchange demonstrates real-world communication patterns found\nin production systems.\n\nKey achievements of this implementation include:\n\n* Successful establishment of TCP socket connections between separate\n  processes\n* Implementation of message-based communication with proper\n  encoding/decoding\n* Demonstration of connection lifecycle management from establishment to\n  termination\n* Creation of a simple command-line interface for both server and client\n  applications\n\nThe knowledge gained from this tutorial serves as a solid foundation for\ndeveloping more sophisticated networked applications. Future\nenhancements could include implementing multithreading for concurrent\nclient handling, adding error handling and reconnection logic, or\nexpanding the communication protocol to support structured data formats. \n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../../styles.css"],"toc":true,"output-file":"sockets.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","theme":["cosmo","brand"],"title":"6 Python Sockets: A Simple Client-Server Example","date":"2025-09-03","date-format":"DD.MM.YYYY","author":"Jacques Mock Schindler"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"lualatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","pdf-engine-opts":["-shell-escape"],"toc":false,"output-file":"sockets.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"mainfont":"Arial","fontsize":"11pt","documentclass":"scrartcl","classoption":"a4paper","listings-package":{"columns":"fullflexible","break-at-whitespace":true},"title":"6 Python Sockets: A Simple Client-Server Example","date":"2025-09-03","date-format":"DD.MM.YYYY","author":"Jacques Mock Schindler"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}